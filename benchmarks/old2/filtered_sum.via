process main {
    val a = Array[int]{A}(100);
    val b = Array[int]{B}(100);
    val c = Array[int]{C}(100);
    for (var i : int = 0; i < 5; i += 1) {
        a[i] = input int from alice;
    }

    for (var i : int = 0; i < 5; i += 1) {
        b[i] = input int from bob;
    }

    for (var i : int = 0; i < 5; i += 1) {
        c[i] = input int from chuck;
    }

    var a_min : int{A} = 0;
    for (var ai : int = 0; ai < 100; ai += 1) {
        a_min = min(a_min, a[ai]);
    }

    var b_min : int{B} = 0;
    for (var bi : int = 0; bi < 100; bi += 1) {
        b_min = min(b_min, b[bi]);
    }
    val a_min_trusted : int = endorse a_min to {A & (B & C)<-};
    val b_min_trusted : int = endorse b_min to {B & (A & C)<-};
    val a_min_greater : bool = declassify (a_min_trusted > b_min_trusted) to {A ⊓ B ⊓ C};
    var filter : int{C};
    if (a_min_greater) {
        filter = declassify b_min_trusted to {A ⊓ B ⊓ C};
    }
    else {
        filter = declassify a_min_trusted to {A ⊓ B ⊓ C};
    }

    var c_sum : int{C} = 0;
    for (var ci : int = 0; ci < 100; ci += 1) {
        c_sum = min(filter, c[ci]);
    }

    val result : int = endorse c_sum to {C & (A & B)<-};

    output (declassify result to {A ⊓ B ⊓ C}) to alice;
    output (declassify result to {A ⊓ B ⊓ C}) to bob;
    output (declassify result to {A ⊓ B ⊓ C}) to chuck;

}

host alice  : {A}
host bob    : {B}
host chuck  : {C}
