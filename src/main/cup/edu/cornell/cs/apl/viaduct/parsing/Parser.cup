import com.google.common.collect.ImmutableList;

import edu.cornell.cs.apl.viaduct.errors.ParsingError;
import edu.cornell.cs.apl.viaduct.protocols.*;
import edu.cornell.cs.apl.viaduct.security.Label;
import edu.cornell.cs.apl.viaduct.security.Principal;
import edu.cornell.cs.apl.viaduct.syntax.*;
import edu.cornell.cs.apl.viaduct.syntax.datatypes.*;
import edu.cornell.cs.apl.viaduct.syntax.surface.*;
import edu.cornell.cs.apl.viaduct.syntax.operators.*;
import edu.cornell.cs.apl.viaduct.syntax.types.*;
import edu.cornell.cs.apl.viaduct.syntax.values.*;

import java.util.List;
import java.util.LinkedList;
import kotlin.collections.CollectionsKt;

import java_cup.runtime.Symbol;


action code {:
    /** Constructs a binary expression node. Source location is inferred from the arguments. */
    private OperatorApplicationNode binaryExpression(BinaryOperator op, ExpressionNode lhs, ExpressionNode rhs) {
        Arguments arguments = Arguments.from(lhs, rhs);
        SourceRange sourceLocation = lhs.getSourceLocation().merge(rhs.getSourceLocation());
        return new OperatorApplicationNode(op, arguments, sourceLocation);
    }

    /** Constructs a label argument list from a single optional label. */
    private Arguments<Located<Label>> optionalLabelArgument(Located<Label> label) {
        if (label == null) {
            return null;
        } else {
            return Arguments.from(label);
        }
    }
:}

parser code {:
    /** Generates source location information for a node given left and right character offsets. */
    private SourceRange location(int left, int right) {
        return ((Lexer) getScanner()).location(left, right);
    }

    @Override
    public void report_error(String message, Object info) {
        report_fatal_error(message, info);
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        done_parsing();

        final Symbol infoSymbol = (Symbol) info;
        final SourceRange errorLocation = location(infoSymbol.left, infoSymbol.right);
        final String actualToken = symbl_name_from_id(infoSymbol.sym);
        final List<String> expectedTokens = new LinkedList<>();
        for (Integer id : expected_token_ids()) {
            expectedTokens.add(symbl_name_from_id(id));
        }
        throw new ParsingError(errorLocation, actualToken, expectedTokens);
    }
:}

nonterminal ProgramNode program;
nonterminal List<TopLevelDeclarationNode> declaration_list;
nonterminal TopLevelDeclarationNode declaration;

nonterminal SimpleStatementNode simple_stmt;
nonterminal ExpressionNode optional_initial_value;
nonterminal BinaryOperator compound_assignment;
nonterminal StatementNode stmt;
nonterminal BlockNode block;
nonterminal List<StatementNode> stmt_list;

nonterminal ExpressionNode expr;
nonterminal List<ExpressionNode> expr_list, nonempty_expr_list;
nonterminal IndexingNode indexing;

nonterminal Value value;
nonterminal Located<ValueType> value_type;
nonterminal Located<Label> label, optional_label, optional_from_label;
nonterminal Label label_expr;

nonterminal Located<ObjectVariable> variable;
nonterminal Located<Host> host;
nonterminal Located<Protocol> protocol;

terminal String IDENT, CAP_IDENT;
terminal int INT_LIT;
terminal TRUE, FALSE;

terminal HOST, PROCESS, PROTOCOL;
terminal COLON;

terminal EQ;
terminal PLUSEQ, MINUSEQ, TIMESEQ, DIVIDEEQ;
terminal LET, VAL, VAR;
terminal IF, ELSE, WHILE, FOR, BREAK;
terminal INPUT, RECEIVE, FROM, OUTPUT, SEND, TO;
terminal ASSERT;

terminal NOT, ANDAND, OROR;
terminal EQEQ, NEQ, LT, LEQ, GT, GEQ;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal MIN, MAX;

terminal DECLASSIFY, ENDORSE, DOWNGRADE;

terminal INT, BOOL, ARRAY;
terminal TOP, BOTTOM, OR, AND, JOIN, MEET, RARROW, LARROW;

terminal OPEN_BRACE, CLOSE_BRACE, SEMICOLON;
terminal OPEN_SQBRACE, CLOSE_SQBRACE;
terminal OPEN_PAREN, CLOSE_PAREN, COMMA;

precedence left ANDAND, OROR, AND, OR, JOIN, MEET;
precedence nonassoc EQEQ, NEQ, LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right NOT, MIN;
precedence left LARROW, RARROW;
precedence nonassoc OPEN_PAREN, CLOSE_PAREN;

start with program;


program ::=
    declaration_list:declarations {:
      RESULT = new ProgramNode(declarations, location(declarationsleft, declarationsright));
    :}
  ;

declaration_list ::=
    declaration_list:declarations declaration:declaration {:
      declarations.add(declaration);
      RESULT = declarations;
    :}

  | /* empty */ {:
      RESULT = CollectionsKt.mutableListOf();
    :}
  ;

declaration ::=
    HOST:begin host:host COLON label:authority {:
      RESULT = new HostDeclarationNode(host, authority, location(beginleft, authorityright));
    :}

  | PROCESS:begin protocol:protocol block:body {:
      RESULT = new ProcessDeclarationNode(protocol, body, location(beginleft, bodyright));
    :}
  ;


simple_stmt ::=
    /* Immutable variable declaration. */
    VAL:begin variable:var COLON value_type:type optional_label:label EQ expr:value {:
      RESULT = new DeclarationNode(
        var,
        new Located(PrimitivesKt.getImmutableCell(), var.getSourceLocation()),
        Arguments.from(type),
        optionalLabelArgument(label),
        Arguments.from(value),
        location(beginleft, valueright));
    :}

    /* Mutable variable declaration. */
  | VAR:begin variable:var COLON value_type:type optional_label:label optional_initial_value:initial {:
      final LiteralNode defaultValue = new LiteralNode(
        type.getValue().getDefaultValue(),
        type.getSourceLocation());

      RESULT = new DeclarationNode(
        var,
        new Located(PrimitivesKt.getMutableCell(), var.getSourceLocation()),
        Arguments.from(type),
        optionalLabelArgument(label),
        Arguments.from((initial == null) ? defaultValue : initial),
        location(beginleft, initialright));
    :}

    /* Array declaration. */
  | VAL:begin variable:var EQ ARRAY OPEN_SQBRACE value_type:elementType CLOSE_SQBRACE
    optional_label:label OPEN_PAREN expr:size CLOSE_PAREN:end {:
      RESULT = new DeclarationNode(
        var,
        new Located(PrimitivesKt.getVector(), var.getSourceLocation()),
        // TODO: Argument source locations below should include the braces
        Arguments.from(elementType),
        optionalLabelArgument(label),  // TODO: add label on size
        Arguments.from(size),
        location(beginleft, endright));
    :}

  | indexing:indexing EQ:eq expr:e {:
      RESULT = indexing.set(e, location(eqleft, eqright));
    :}

  | indexing:indexing compound_assignment:op expr:e {:
      RESULT = indexing.modify(op, e, location(opleft, opright));
    :}

  | OUTPUT:begin expr:message TO host:recipient {:
      RESULT = new OutputNode(message, recipient, location(beginleft, recipientright));
    :}

  | SEND:begin expr:message TO protocol:recipient {:
      RESULT = new SendNode(message, recipient, location(beginleft, recipientright));
    :}
  ;

optional_initial_value ::=
    EQ expr:e    {: RESULT = e; :}
  | /* empty */  {: RESULT = null; :}
  ;

compound_assignment ::=
    PLUSEQ   {: RESULT = Addition.INSTANCE; :}
  | MINUSEQ  {: RESULT = Subtraction.INSTANCE; :}
  | TIMESEQ  {: RESULT = Multiplication.INSTANCE; :}
  | DIVIDEEQ {: RESULT = Division.INSTANCE; :}
  ;

stmt ::=
    simple_stmt:stmt SEMICOLON {:
      RESULT = stmt;
    :}

  | IF:begin OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase ELSE block:elseCase {:
      RESULT = new IfNode(guard, thenCase, elseCase, location(beginleft, elseCaseright));
    :}

  | IF:begin OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase {:
      SourceRange sourceLocation = location(beginleft , thenCaseright);
      RESULT = new IfNode(
        guard,
        thenCase,
        new BlockNode(CollectionsKt.listOf(), sourceLocation),
        sourceLocation);
    :}

  | WHILE:begin OPEN_PAREN expr:guard CLOSE_PAREN block:body {:
      RESULT = new WhileLoopNode(guard, body, null, location(beginleft, bodyright));
    :}

  | FOR:begin OPEN_PAREN simple_stmt:initialize SEMICOLON expr:guard SEMICOLON simple_stmt:update CLOSE_PAREN block:body {:
      RESULT = new ForLoopNode(initialize, guard, update, body, null, location(beginleft, bodyright));
    :}

  | BREAK:brk SEMICOLON {:
      RESULT = new BreakNode(null, location(brkleft, brkright));
    :}

  | ASSERT:begin expr:e SEMICOLON {:
      RESULT = new AssertionNode(e, location(beginleft, eright));
    :}

  | block:block {:
      RESULT = block;
    :}
  ;

block ::=
    OPEN_BRACE:begin stmt_list:statements CLOSE_BRACE:end {:
      RESULT = new BlockNode(statements, location(beginleft, endright));
    :}
  ;

stmt_list ::=
    stmt_list:slist stmt:s {:
      slist.add(s);
      RESULT = slist;
    :}

  | /* empty */ {:
      RESULT = CollectionsKt.mutableListOf();
    :}
  ;


expr ::=
    value:value {:
      RESULT = new LiteralNode(value, location(valueleft, valueright));
    :}

  | indexing:indexing {:
       RESULT = indexing.get();
    :}

  | NOT:begin expr:e {:
      RESULT = new OperatorApplicationNode(
        Not.INSTANCE,
        Arguments.from(e),
        location(beginleft, eright));
    :}

  | MINUS:begin expr:e {:
      RESULT = new OperatorApplicationNode(
        Negation.INSTANCE,
        Arguments.from(e),
        location(beginleft, eright));
    :}

  | expr:e1 ANDAND expr:e2 {:
      RESULT = binaryExpression(And.INSTANCE, e1, e2);
    :}

  | expr:e1 OROR expr:e2 {:
      RESULT = binaryExpression(Or.INSTANCE, e1, e2);
    :}

  | expr:e1 EQEQ expr:e2 {:
      RESULT = binaryExpression(EqualTo.INSTANCE, e1, e2);
    :}

  | expr:e1 NEQ expr:e2 {:
      final ExpressionNode eq = binaryExpression(EqualTo.INSTANCE, e1, e2);
      RESULT = new OperatorApplicationNode(Not.INSTANCE, Arguments.from(eq), eq.getSourceLocation());
    :}

  | expr:e1 LT expr:e2 {:
      RESULT = binaryExpression(LessThan.INSTANCE, e1, e2);
    :}

  | expr:e1 LEQ expr:e2 {:
      RESULT = binaryExpression(LessThanOrEqualTo.INSTANCE, e1, e2);
    :}

  | expr:e1 GT expr:e2 {:
      RESULT = binaryExpression(LessThan.INSTANCE, e2, e1);
    :}

  | expr:e1 GEQ expr:e2 {:
      RESULT = binaryExpression(LessThanOrEqualTo.INSTANCE, e2, e1);
    :}

  | expr:e1 PLUS expr:e2 {:
      RESULT = binaryExpression(Addition.INSTANCE, e1, e2);
    :}

  | expr:e1 MINUS expr:e2 {:
      RESULT = binaryExpression(Subtraction.INSTANCE, e1, e2);
    :}

  | expr:e1 TIMES expr:e2 {:
      RESULT = binaryExpression(Multiplication.INSTANCE, e1, e2);
    :}

  | expr:e1 DIVIDE expr:e2 {:
      RESULT = binaryExpression(Division.INSTANCE, e1, e2);
    :}

  | MIN:begin OPEN_PAREN expr:e1 COMMA expr:e2 CLOSE_PAREN:end {:
      RESULT = binaryExpression(Minimum.INSTANCE, e1, e2);
    :}

  | MAX:begin OPEN_PAREN expr:e1 COMMA expr:e2 CLOSE_PAREN:end {:
      RESULT = binaryExpression(Maximum.INSTANCE, e1, e2);
    :}

  | DECLASSIFY:begin expr:e optional_from_label:from TO label:to {:
      // TODO: Add from labels.
      RESULT = new DeclassificationNode(e, from, to, location(beginleft, toright));
    :}

  | ENDORSE:begin expr:e optional_from_label:from TO label:to {:
      RESULT = new EndorsementNode(e, from, to, location(beginleft, toright));
    :}

  | INPUT:begin value_type:type FROM host:sender {:
      RESULT = new InputNode(type, sender, location(beginleft, senderright));
    :}

  | RECEIVE:begin value_type:type FROM protocol:sender {:
      RESULT = new ReceiveNode(type, sender, location(beginleft, senderright));
    :}

  | OPEN_PAREN expr:e CLOSE_PAREN {:
      RESULT = e;
    :}
  ;

expr_list ::=
    nonempty_expr_list:elist {:
      RESULT = elist;
    :}

  | /* empty */ {:
      RESULT = CollectionsKt.listOf();
    :}
  ;

nonempty_expr_list ::=
    nonempty_expr_list:elist COMMA expr:e {:
      elist.add(e);
      RESULT = elist;
    :}

  | expr:e {:
      RESULT = CollectionsKt.mutableListOf(e);
    :}
  ;

indexing ::=
    variable:var {:
      RESULT = new IndexingNode(var, new Arguments(location(varleft, varright)));
    :}

  | variable:var OPEN_SQBRACE:open nonempty_expr_list:indices CLOSE_SQBRACE:close {:
      RESULT = new IndexingNode(var, new Arguments(indices, location(openleft, closeright)));
    :}
  ;


value ::=
    TRUE {:
      RESULT = new BooleanValue(true);
    :}

  | FALSE {:
      RESULT = new BooleanValue(false);
    :}

  | INT_LIT:literal {:
      RESULT = new IntegerValue(literal);
    :}
  ;


value_type ::=
    INT:type {:
      RESULT = new Located(IntegerType.INSTANCE, location(typeleft, typeright));
    :}
  | BOOL:type {:
      RESULT = new Located(BooleanType.INSTANCE, location(typeleft, typeright));
    :}
  ;


label ::=
    OPEN_BRACE:begin label_expr:l CLOSE_BRACE:end {:
      RESULT = new Located(l, location(beginleft, endright));
    :}
  ;

label_expr ::=
    CAP_IDENT:id {: RESULT = Label.create(Principal.create(id)); :}

  | TOP {: RESULT = Label.weakest(); :}

  | BOTTOM {: RESULT = Label.strongest(); :}

  | label_expr:l1 OR label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 AND label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 JOIN label_expr:l2 {:
      RESULT = l1.join(l2);
    :}

  | label_expr:l1 MEET label_expr:l2 {:
      RESULT = l1.meet(l2);
    :}

  | label_expr:l RARROW {:
      RESULT = l.confidentiality();
    :}

  | label_expr:l LARROW {:
      RESULT = l.integrity();
    :}

  | OPEN_PAREN label_expr:l CLOSE_PAREN {:
      RESULT = l;
    :}
  ;


optional_label ::=
    label:l     {: RESULT = l; :}
  | /* empty */ {: RESULT = null; :}
  ;

optional_from_label ::=
    FROM label:l {: RESULT = l; :}
  | /* empty */  {: RESULT = null; :}
  ;


variable ::=
    IDENT:id  {:
      RESULT = new Located(new ObjectVariable(id), location(idleft, idright));
    :}
  ;

host ::=
    IDENT:id {:
      RESULT = new Located(new Host(id), location(idleft, idright));
    :}
  ;

protocol ::=
    IDENT:id {:
      RESULT = new Located(new Ideal(id), location(idleft, idright));
    :}

  | CAP_IDENT:protocolName OPEN_PAREN host:host CLOSE_PAREN:end {:
      // TODO: parse this properly
      RESULT = new Located(
        new Ideal(host.getValue().getName()),
        location(protocolNameleft, endright));
    :}
  ;
