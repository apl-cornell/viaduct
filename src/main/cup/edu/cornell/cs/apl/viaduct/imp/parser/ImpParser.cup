import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList;

import edu.cornell.cs.apl.viaduct.imp.ast.*;
import edu.cornell.cs.apl.viaduct.imp.ast.BinaryOperators.*;
import edu.cornell.cs.apl.viaduct.security.Label;
import edu.cornell.cs.apl.viaduct.security.Principal;

nonterminal ProgramNode program;
nonterminal ProgramNode.Builder declaration_list;
nonterminal List<StmtNode> stmt_list;
nonterminal StmtNode stmt, stmt_basic, block;
nonterminal Reference reference;
nonterminal ExpressionNode expr;
nonterminal ImpValue value;
nonterminal Label label, label_expr;
nonterminal Variable variable;
nonterminal Host host;
nonterminal ProcessName process_name;
nonterminal ImpType type;

terminal String IDENT, CAP_IDENT;
terminal Integer INT_LIT;
terminal TRUE, FALSE;

terminal INT, BOOL;

terminal COLON;
terminal ASSERT, SEND, TO, RECV, FROM, IF, ELSE, WHILE, FOR;
terminal HOST, PROCESS, PROTOCOL, IDEAL;

terminal NOT, ANDAND, OROR;
terminal EQ, EQEQ, NEQ, LT, LEQ, GT, GEQ, PLUSEQ, MINUSEQ, TIMESEQ;
terminal TOP, BOTTOM, OR, AND, RARROW, LARROW;
terminal SQCUP, SQCAP, WEDGE, VEE;

terminal PLUS, MINUS, TIMES, PLUSPLUS, MINUSMINUS;
// terminal PLUS, MINUS, TIMES, DIVIDE;

terminal DECLASSIFY, ENDORSE, DOWNGRADE;

terminal OPEN_BRACE, CLOSE_BRACE, OPEN_SQBRACE, CLOSE_SQBRACE, SEMICOLON, OPEN_PAREN, CLOSE_PAREN, COMMA;

precedence left ANDAND, OROR, AND, OR, SQCUP, SQCAP, WEDGE, VEE;
precedence nonassoc EQEQ, NEQ, LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT;
precedence left LARROW, RARROW, NOT;
precedence nonassoc OPEN_PAREN, CLOSE_PAREN;

start with program;


program ::=
    declaration_list:declarations {: RESULT = declarations.build(); :}
  ;

declaration_list ::=
    HOST host:host COLON label:trust SEMICOLON declaration_list:declarations {:
      declarations.addHost(host, trust);
      RESULT = declarations;
    :}

  | PROCESS process_name:processName block:block declaration_list:declarations {:
      declarations.addProcess(processName, block);
      RESULT = declarations;
    :}

  | /* empty */ {:
      RESULT = ProgramNode.builder();
  :}
  ;

type ::=
    INT {: RESULT = IntegerType.create(); :}
  | BOOL {: RESULT = BooleanType.create(); :}
  ;

stmt ::=
    stmt_basic:stmt SEMICOLON {:
      RESULT = stmt;
    :}

  | IF OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase ELSE block:elseCase {:
      RESULT = new IfNode(guard, thenCase, elseCase);
    :}

  | IF OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase {:
      RESULT = new IfNode(guard, thenCase);
    :}

  | WHILE OPEN_PAREN expr:guard CLOSE_PAREN block:body {:
      RESULT = new WhileNode(guard, body);
    :}

  | FOR OPEN_PAREN stmt_basic:initialzer SEMICOLON expr:guard SEMICOLON stmt_basic:update CLOSE_PAREN block:body {:
      RESULT = new ForNode(initialzer, guard, update, body);
    :}

  | block:block {:
      RESULT = block;
    :}
  ;

stmt_basic ::=
    variable:var COLON type:ty label:lab {:
      RESULT = new VariableDeclarationNode(var, ty, lab);
    :}

  | variable:var OPEN_SQBRACE expr:e CLOSE_SQBRACE COLON type:ty label:lab {:
      RESULT = new ArrayDeclarationNode(var, e, ty, lab);
    :}

  | reference:ref EQ expr:e {:
      RESULT = new AssignNode(ref, e);
    :}

  | reference:ref PLUSEQ expr:e {:
      ExpressionNode rhs = BinaryExpressionNode.create(new ReadNode(ref), Plus.create(), e);
      RESULT = new AssignNode(ref, rhs);
    :}

  | reference:ref MINUSEQ expr:e {:
      ExpressionNode rhs = BinaryExpressionNode.create(new ReadNode(ref), Minus.create(), e);
      RESULT = new AssignNode(ref, rhs);
    :}

  | reference:ref TIMESEQ expr:e {:
      ExpressionNode rhs = BinaryExpressionNode.create(new ReadNode(ref), Times.create(), e);
      RESULT = new AssignNode(ref, rhs);
    :}

  | reference:ref PLUSPLUS {:
      ExpressionNode rhs = BinaryExpressionNode.create(new ReadNode(ref), Plus.create(), new LiteralNode(new IntegerValue(1)));
      RESULT = new AssignNode(ref, rhs);
    :}

  | reference:ref MINUSMINUS {:
      ExpressionNode rhs = BinaryExpressionNode.create(new ReadNode(ref), Minus.create(), new LiteralNode(new IntegerValue(1)));
      RESULT = new AssignNode(ref, rhs);
    :}

  | SEND expr:e TO process_name:processName {:
      RESULT = new SendNode(processName, e);
    :}

  | variable:var LARROW RECV process_name:processName {:
      RESULT = new ReceiveNode(var, processName);
    :}

  | variable:var LARROW RECV type:ty process_name:processName {:
      RESULT = new ReceiveNode(var, ty, processName);
    :}

  | ASSERT expr:e {:
      RESULT = new AssertNode(e);
    :}
  ;

block ::=
    OPEN_BRACE stmt_list:slist CLOSE_BRACE {:
      RESULT = new BlockNode(slist);
    :}
  ;

stmt_list ::=
    stmt_list:slist stmt:s {:
      slist.add(s);
      RESULT = slist;
    :}

  | /* empty */ {:
        RESULT = new LinkedList<>();
    :}
  ;

reference ::=
    variable:var OPEN_SQBRACE expr:e CLOSE_SQBRACE {:
      RESULT = new ArrayIndex(var, e);

    :}

  | variable:var {:
      RESULT = var;
    :}
  ;

expr ::=
    value:value {:
      RESULT = new LiteralNode(value);
    :}

  | reference:ref {:
       RESULT = new ReadNode(ref);
    :}

  | NOT expr:e {:
      RESULT = new NotNode(e);
    :}

  | expr:e1 OROR expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, Or.create(), e2);
    :}

  | expr:e1 ANDAND expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, And.create(), e2);
    :}

  | expr:e1 EQEQ expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, EqualTo.create(), e2);
    :}

  | expr:e1 NEQ expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e1, EqualTo.create(), e2));
    :}

  | expr:e1 LT expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, LessThan.create(), e2);
    :}

  | expr:e1 LEQ expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, LessThanOrEqualTo.create(), e2);
    :}

  | expr:e1 GT expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e2, LessThan.create(), e1));
    :}

  | expr:e1 GEQ expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e2, LessThanOrEqualTo.create(), e1));
    :}

  | expr:e1 PLUS expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, Plus.create(), e2);
    :}

  | expr:e1 MINUS expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, Minus.create(), e2);
    :}

  | expr:e1 TIMES expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, Times.create(), e2);
    :}

  | DECLASSIFY OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | ENDORSE OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | DOWNGRADE OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | OPEN_PAREN expr:e CLOSE_PAREN {:
      RESULT = e;
    :}
  ;

value ::=
    TRUE {:
      RESULT = new BooleanValue(true);
    :}

  | FALSE {:
      RESULT = new BooleanValue(false);
    :}

  | INT_LIT:lit {:
      RESULT = new IntegerValue(lit);
    :}
  ;

label ::=
    OPEN_BRACE CLOSE_BRACE {: RESULT = Label.bottom(); :}

  | OPEN_BRACE label_expr:l CLOSE_BRACE {: RESULT = l; :}
  ;

label_expr ::=
    CAP_IDENT:id {: RESULT = new Label(new Principal(id)); :}

  | TOP {: RESULT = Label.strongest(); :}

  | BOTTOM {: RESULT = Label.weakest(); :}

  | label_expr:l1 OR label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 VEE label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 AND label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 WEDGE label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 OROR label_expr:l2 {:
      RESULT = l1.join(l2);
    :}

  | label_expr:l1 SQCUP label_expr:l2 {:
      RESULT = l1.join(l2);
    :}

  | label_expr:l1 ANDAND label_expr:l2 {:
      RESULT = l1.meet(l2);
    :}

  | label_expr:l1 SQCAP label_expr:l2 {:
      RESULT = l1.meet(l2);
    :}

  | label_expr:l RARROW {:
      RESULT = l.confidentiality();
    :}

  | label_expr:l LARROW {:
      RESULT = l.integrity();
    :}

  | OPEN_PAREN label_expr:l CLOSE_PAREN {:
      RESULT = l;
    :}
  ;

variable ::=
    IDENT:id  {: RESULT = new Variable(id); :}
  ;

host ::=
    IDENT:id {: RESULT = new Host(id); :}
  ;

process_name ::=
    IDENT:id {: RESULT = new ProcessName(id); :}
  ;
