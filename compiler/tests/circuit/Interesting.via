host alice
host bob

/* Biometric matching */
circuit fun <n, d> biometric@YaoABY(client = bob, server = alice)(
    database: int[n, d]@Local(host = alice),
    sample: int[d]@Local(host = bob)
) → dist: int[]@Replication(hosts = {alice, bob}) {
    val dists[i < n] = reduce(::+, 0) { j < d -> (database[i, j] - sample[j]) * (database[i, j] - sample[j]) }
    return reduce(::min, 999999) { i < n -> dists[i] }
}

/* Calculates the Herfindahl-Hirschman index for market competitiveness. */
circuit fun <stores> hhi@YaoABY(client = bob, server = alice)(
    a_sales: int[stores]@Local(host = alice),
    b_sales: int[stores]@Local(host = bob)
) → hhi: int[]@Local(host = alice) {
    val revenues[i < 2] = reduce(::+, 0) { j < stores -> mux(i == 0, a_sales[j], b_sales[j]) }
    val total[] = reduce(::+, 0) { i < n -> revenues[i] }
    return reduce(::+, 0) { i < n -> ((100 * revenues[i]) / total[]) * ((100 * revenues[i]) / total[]) }
}

/* Historical millionaires */
circuit fun <n> historical@YaoABY(client = bob, server = alice)(
    a: int[n]@Local(host = alice),
    b: int[n]@Local(host = bob)
) → a_wins: bool[]@Local(host = alice) {
    val a_min[] = reduce(::min, 999999) { i < n -> a[i] }
    val b_min[] = reduce(::min, 999999) { i < n -> b[i] }
    return a_min[] > b_min[]
}

/* One-round bidding for n items; not two-rounds because inputs/outputs not permitted in circuits */
circuit fun <n> bidding@YaoABY(client = bob, server = alice)(
    a: int[n]@Local(host = alice),
    b: int[n]@Local(host = bob)
) → a_wins: bool[n]@Local(host = alice) {
    val a_wins[i < n] = a[i] < b[i]
    return a_wins
}
