{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Viaduct \u00b6 Viaduct is an extensible, optimizing compiler for secure distributed programs. It lets developers write programs in a simple sequential language that embeds high-level security policies using information flow labels. Viaduct then compiles the source program into a distributed implementation that employs cryptography to defend the security policy. Viaduct is extensible : it provides a set of well-defined interfaces that developers can implement to add support for new cryptographic mechanisms. Because of its novel design, Viaduct does not place limitations on the source programs it can compile, such as the number of participants or trust assumptions between participants. Viaduct uses a cost model to generate efficient distributed programs, avoiding the use of expensive cryptography unless necessary. Our prototype compiler and runtime, written in Kotlin, can be found on Github . It currently supports the following cryptographic mechanisms: multiparty computation (via ABY ) zero-knowledge proofs (via libsnark ) commitments (SHA256 hash + nonce) More details about the compiler can be found in our PLDI 2021 paper .","title":"Viaduct"},{"location":"#viaduct","text":"Viaduct is an extensible, optimizing compiler for secure distributed programs. It lets developers write programs in a simple sequential language that embeds high-level security policies using information flow labels. Viaduct then compiles the source program into a distributed implementation that employs cryptography to defend the security policy. Viaduct is extensible : it provides a set of well-defined interfaces that developers can implement to add support for new cryptographic mechanisms. Because of its novel design, Viaduct does not place limitations on the source programs it can compile, such as the number of participants or trust assumptions between participants. Viaduct uses a cost model to generate efficient distributed programs, avoiding the use of expensive cryptography unless necessary. Our prototype compiler and runtime, written in Kotlin, can be found on Github . It currently supports the following cryptographic mechanisms: multiparty computation (via ABY ) zero-knowledge proofs (via libsnark ) commitments (SHA256 hash + nonce) More details about the compiler can be found in our PLDI 2021 paper .","title":"Viaduct"},{"location":"developer-guide/building/","text":"Building \u00b6 We use Gradle for builds. You do not have to install Gradle manually; you only need to have Java available. Once you have Java installed, just run ./gradlew build to build the code. This will also run all tests, so if this command works, you are good to go. On Unix environments, you can run the compiler using ./viaduct from project root. This will use Gradle to automatically rebuild the application as necessary, so you do not have to worry about calling ./gradlew build each time you change something. To start, try ./viaduct --help Building back ends \u00b6 ABY \u00b6 We use ABY for our secure multiparty computation back end. We have bundled ABY as a Java library (see aby-java ), so no additional setup is necessary to make it work. Warning aby-java currently does not support Windows. libsnark \u00b6 We use libsnark for our zero-knowledge proofs back end. You have to manually build the JNI wrapper for libsnark to use the ZKP back end. First, clone libfqfft : https://github.com/scipr-lab/libfqfft . libsnark actually depends on this library, but we have to build it ourselves because we need to set the -fPIC flag manually to get the wrapper to build. To build, navigate to the root of the repository and run this on your shell: mkdir build && cd build && cmake -DCMAKE_POSITION_INDEPENDENT_CODE=ON .. . Then run make and then make install to install the libraries and header files. Next, clone libsnark : https://github.com/scipr-lab/libsnark . Run this command in the root of the repository: mkdir build && cd build && cmake -DUSE_LINKED_LIBRARIES=ON .. . The cmake flag makes the build use the installed version of libfqfft instead of building it again in the depends subrepository. Then run make and then make install to install the libraries and header files. Finally, build the libsnark wrapper. Navigate to this directory of the viaduct repository: runtime/src/main/cwrapper . Next, inspect the Makefile and make sure that the INCLUDES variable points to the JVM directories. Then inspect the libsnarkwrapper.so target and make sure the link directory ( -L ) points to the directory where libff and libsnark were installed. Run make to build libsnarkwrapper. Finally, run make install to install the wrapper in a directory known by the JVM to include JNI libraries. By default, the install target will copy the wrapper in /usr/lib/ .","title":"Building"},{"location":"developer-guide/building/#building","text":"We use Gradle for builds. You do not have to install Gradle manually; you only need to have Java available. Once you have Java installed, just run ./gradlew build to build the code. This will also run all tests, so if this command works, you are good to go. On Unix environments, you can run the compiler using ./viaduct from project root. This will use Gradle to automatically rebuild the application as necessary, so you do not have to worry about calling ./gradlew build each time you change something. To start, try ./viaduct --help","title":"Building"},{"location":"developer-guide/building/#building-back-ends","text":"","title":"Building back ends"},{"location":"developer-guide/building/#aby","text":"We use ABY for our secure multiparty computation back end. We have bundled ABY as a Java library (see aby-java ), so no additional setup is necessary to make it work. Warning aby-java currently does not support Windows.","title":"ABY"},{"location":"developer-guide/building/#libsnark","text":"We use libsnark for our zero-knowledge proofs back end. You have to manually build the JNI wrapper for libsnark to use the ZKP back end. First, clone libfqfft : https://github.com/scipr-lab/libfqfft . libsnark actually depends on this library, but we have to build it ourselves because we need to set the -fPIC flag manually to get the wrapper to build. To build, navigate to the root of the repository and run this on your shell: mkdir build && cd build && cmake -DCMAKE_POSITION_INDEPENDENT_CODE=ON .. . Then run make and then make install to install the libraries and header files. Next, clone libsnark : https://github.com/scipr-lab/libsnark . Run this command in the root of the repository: mkdir build && cd build && cmake -DUSE_LINKED_LIBRARIES=ON .. . The cmake flag makes the build use the installed version of libfqfft instead of building it again in the depends subrepository. Then run make and then make install to install the libraries and header files. Finally, build the libsnark wrapper. Navigate to this directory of the viaduct repository: runtime/src/main/cwrapper . Next, inspect the Makefile and make sure that the INCLUDES variable points to the JVM directories. Then inspect the libsnarkwrapper.so target and make sure the link directory ( -L ) points to the directory where libff and libsnark were installed. Run make to build libsnarkwrapper. Finally, run make install to install the wrapper in a directory known by the JVM to include JNI libraries. By default, the install target will copy the wrapper in /usr/lib/ .","title":"libsnark"},{"location":"developer-guide/dependencies/","text":"Updating Dependencies \u00b6 We use a Gradle plugin for managing dependencies. Running ./gradlew dependencyUpdates will give you a report listing outdated dependencies. You can now either manually change build.gradle.kts , or run ./gradlew useLatestVersions to automatically update all dependencies. To update Gradle itself, run ./gradlew wrapper --gradle-version <version> where <version> comes from the above report.","title":"Updating Dependencies"},{"location":"developer-guide/dependencies/#updating-dependencies","text":"We use a Gradle plugin for managing dependencies. Running ./gradlew dependencyUpdates will give you a report listing outdated dependencies. You can now either manually change build.gradle.kts , or run ./gradlew useLatestVersions to automatically update all dependencies. To update Gradle itself, run ./gradlew wrapper --gradle-version <version> where <version> comes from the above report.","title":"Updating Dependencies"},{"location":"developer-guide/documentation/","text":"Updating Documentation \u00b6 We use MkDocs to generate documentation. See: mkdocs documentation . mkdocs-material documentation . Project layout \u00b6 docs/ mkdocs.yml # The configuration file. src/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Gradle tasks \u00b6 mkdocsBuild - Build the documentation site. mkdocsServe --no-daemon - Start the live-reloading docs server.","title":"Updating Documentation"},{"location":"developer-guide/documentation/#updating-documentation","text":"We use MkDocs to generate documentation. See: mkdocs documentation . mkdocs-material documentation .","title":"Updating Documentation"},{"location":"developer-guide/documentation/#project-layout","text":"docs/ mkdocs.yml # The configuration file. src/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"developer-guide/documentation/#gradle-tasks","text":"mkdocsBuild - Build the documentation site. mkdocsServe --no-daemon - Start the live-reloading docs server.","title":"Gradle tasks"},{"location":"developer-guide/logging/","text":"Logging \u00b6 We use the kotlin-logging library for showing additional information to the user. Logs go to standard error in accordance with Unix conventions, and the user can control the granularity of logs using the --verbose flag. As a general rule, never use print() or println() to display information to the user. This includes showing information to yourself for debugging. All logging frameworks have a DEGUB level, and if you found this information useful, chances are it will be relevant later. Logging is extremely easy to use. See this section of the Kotlin library.","title":"Logging"},{"location":"developer-guide/logging/#logging","text":"We use the kotlin-logging library for showing additional information to the user. Logs go to standard error in accordance with Unix conventions, and the user can control the granularity of logs using the --verbose flag. As a general rule, never use print() or println() to display information to the user. This includes showing information to yourself for debugging. All logging frameworks have a DEGUB level, and if you found this information useful, chances are it will be relevant later. Logging is extremely easy to use. See this section of the Kotlin library.","title":"Logging"},{"location":"user-guide/compiling-and-running/","text":"Using the Compiler \u00b6 There are two main compiler commands you need to know. The compile command compiles Viaduct source programs into distributed programs. The run command allows hosts to execute a compiled distributed program together. We will go over the basics of using these two commands in the following sections. You can run viaduct compile --help and viaduct run --help to get more information about each of these commands and the various options and flags they support. Compiling Source Programs \u00b6 As an example, we will compile the examples/Millionaires.via program, which is an implementation of the standard Millionaires' problem in Viaduct. You can view the source program with the following command: less examples/Millionaires.via Note that this and other programs in the examples directory are purposefully simple; you can find more complex examples under the benchmarks directory. Run the following to compile the program: viaduct -v compile examples/Millionaires.via This will print the compiled program to the standard output. The -v option turns on detailed logging, and must come before the command name (e.g., viaduct compile -v will not work). You can repeat it (e.g., -vvv ) for more granular messages, or leave it out. To save the compiled file to disk, provide the -o option along with a file name: viaduct -v compile examples/Millionaires.via -o m-out.via You should see logging information that looks like this: 1015 ms [main] INFO Compile - elaborating source program... 1110 ms [main] INFO Compile - specializing functions... 1115 ms [main] INFO Check - name analysis... 1149 ms [main] INFO Check - type checking... 1159 ms [main] INFO Check - out parameter initialization analysis... 1165 ms [main] INFO Check - information flow analysis... 1251 ms [main] INFO InformationFlowAnalysis - number of label variables: 28 1251 ms [main] INFO Check - finished information flow analysis, ran for 87ms 1272 ms [main] INFO Compile - selecting protocols... 1779 ms [main] INFO Z3Selection - number of symvars: 91 1779 ms [main] INFO Z3Selection - cost mode set to MINIMIZE 1828 ms [main] INFO Z3Selection - constraints satisfiable, extracted model 1834 ms [main] INFO Compile - finished protocol selection, ran for 519ms 1842 ms [main] INFO Compile - annotating program with protocols... You can view the compiled program: less m-out.via Notice that the compiled program is an elaborated version of the source program where each variable declaration and let binding is annotated with the protocol that will execute it. Running Compiled Programs \u00b6 The run command takes as arguments a host name and a compiled program, and executes the host's \"projection\" of the distributed program. Since compiled programs are distributed, we need to run multiple instances of Viaduct. For instance, to execute our example program m-out.via , we need two participants standing in for hosts alice and bob , respectively. The easiest way to accomplish this from the single terminal window we have is to run one of the commands in the background: viaduct -v run alice m-out.via -in inputs/alice.txt & viaduct -v run bob m-out.via -in inputs/bob.txt Here, we run two instances with logging enabled (the -v option), and provide inputs from files ( -in FILENAME ). An alternative to running one of the instances in the background is using Tmux and running each participant in a different pane. This method allows you to manually provide input to each participant. However, we only recommend this alternative if you are already familiar with Tmux (or are willing to pick up the basics). Here is a very quick tutorial to get you started: Start a new session by typing tmux . Split your terminal using the keyboard shortcut Ctrl+b \" . Switch between panes using Ctrl+b <arrow key> (up and down keys specifically). Execute the following two commands in separate panes: viaduct run alice m-out.via -in inputs/alice.txt viaduct run bob m-out.via -in inputs/bob.txt We recommend starting Alice's process first; you may get a \"connection timed out\" error otherwise. Quit Tmux by typing tmux kill-session . You can provide input manually for one or both of the participants by omitting the -in option (we also recommend leaving out the -v option). The participant will block on an Input: prompt when you need to provide input. You can repeat these steps for the other programs in the examples and benchmarks directories. However, programs in the benchmarks directory expect many (sometimes hundreds) of inputs, so we don't recommend providing inputs by hand! Editing files \u00b6 You can edit files using the nano editor: nano examples/Millionaires.via","title":"Using the Compiler"},{"location":"user-guide/compiling-and-running/#using-the-compiler","text":"There are two main compiler commands you need to know. The compile command compiles Viaduct source programs into distributed programs. The run command allows hosts to execute a compiled distributed program together. We will go over the basics of using these two commands in the following sections. You can run viaduct compile --help and viaduct run --help to get more information about each of these commands and the various options and flags they support.","title":"Using the Compiler"},{"location":"user-guide/compiling-and-running/#compiling-source-programs","text":"As an example, we will compile the examples/Millionaires.via program, which is an implementation of the standard Millionaires' problem in Viaduct. You can view the source program with the following command: less examples/Millionaires.via Note that this and other programs in the examples directory are purposefully simple; you can find more complex examples under the benchmarks directory. Run the following to compile the program: viaduct -v compile examples/Millionaires.via This will print the compiled program to the standard output. The -v option turns on detailed logging, and must come before the command name (e.g., viaduct compile -v will not work). You can repeat it (e.g., -vvv ) for more granular messages, or leave it out. To save the compiled file to disk, provide the -o option along with a file name: viaduct -v compile examples/Millionaires.via -o m-out.via You should see logging information that looks like this: 1015 ms [main] INFO Compile - elaborating source program... 1110 ms [main] INFO Compile - specializing functions... 1115 ms [main] INFO Check - name analysis... 1149 ms [main] INFO Check - type checking... 1159 ms [main] INFO Check - out parameter initialization analysis... 1165 ms [main] INFO Check - information flow analysis... 1251 ms [main] INFO InformationFlowAnalysis - number of label variables: 28 1251 ms [main] INFO Check - finished information flow analysis, ran for 87ms 1272 ms [main] INFO Compile - selecting protocols... 1779 ms [main] INFO Z3Selection - number of symvars: 91 1779 ms [main] INFO Z3Selection - cost mode set to MINIMIZE 1828 ms [main] INFO Z3Selection - constraints satisfiable, extracted model 1834 ms [main] INFO Compile - finished protocol selection, ran for 519ms 1842 ms [main] INFO Compile - annotating program with protocols... You can view the compiled program: less m-out.via Notice that the compiled program is an elaborated version of the source program where each variable declaration and let binding is annotated with the protocol that will execute it.","title":"Compiling Source Programs"},{"location":"user-guide/compiling-and-running/#running-compiled-programs","text":"The run command takes as arguments a host name and a compiled program, and executes the host's \"projection\" of the distributed program. Since compiled programs are distributed, we need to run multiple instances of Viaduct. For instance, to execute our example program m-out.via , we need two participants standing in for hosts alice and bob , respectively. The easiest way to accomplish this from the single terminal window we have is to run one of the commands in the background: viaduct -v run alice m-out.via -in inputs/alice.txt & viaduct -v run bob m-out.via -in inputs/bob.txt Here, we run two instances with logging enabled (the -v option), and provide inputs from files ( -in FILENAME ). An alternative to running one of the instances in the background is using Tmux and running each participant in a different pane. This method allows you to manually provide input to each participant. However, we only recommend this alternative if you are already familiar with Tmux (or are willing to pick up the basics). Here is a very quick tutorial to get you started: Start a new session by typing tmux . Split your terminal using the keyboard shortcut Ctrl+b \" . Switch between panes using Ctrl+b <arrow key> (up and down keys specifically). Execute the following two commands in separate panes: viaduct run alice m-out.via -in inputs/alice.txt viaduct run bob m-out.via -in inputs/bob.txt We recommend starting Alice's process first; you may get a \"connection timed out\" error otherwise. Quit Tmux by typing tmux kill-session . You can provide input manually for one or both of the participants by omitting the -in option (we also recommend leaving out the -v option). The participant will block on an Input: prompt when you need to provide input. You can repeat these steps for the other programs in the examples and benchmarks directories. However, programs in the benchmarks directory expect many (sometimes hundreds) of inputs, so we don't recommend providing inputs by hand!","title":"Running Compiled Programs"},{"location":"user-guide/compiling-and-running/#editing-files","text":"You can edit files using the nano editor: nano examples/Millionaires.via","title":"Editing files"},{"location":"user-guide/getting-started/","text":"Getting Started \u00b6 The easiest way to try out Viaduct is by using Docker. After installing Docker , run the following in a terminal: docker run --rm -it aplcornell/viaduct This will drop you in a Docker container that has the Viaduct compiler installed. To get started, try viaduct --help To build Viaduct from source code, refer to the Developer's Guide .","title":"Getting Started"},{"location":"user-guide/getting-started/#getting-started","text":"The easiest way to try out Viaduct is by using Docker. After installing Docker , run the following in a terminal: docker run --rm -it aplcornell/viaduct This will drop you in a Docker container that has the Viaduct compiler installed. To get started, try viaduct --help To build Viaduct from source code, refer to the Developer's Guide .","title":"Getting Started"}]}