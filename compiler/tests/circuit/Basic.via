host alice
host bob

circuit fun <> basic@YaoABY(client = bob, server = alice)(a: int[], b: int[]) â†’ d: int[], e: int[]{
    val c[]: int[] = a[] + b[]
    return c
}

fun <> main() -> {
    val a@Local(host = alice) = alice.input<int[10]>()
    val b@Local(host = bob) = alice.input<int[]>()
    val u@Local(host = alice) = alice.output<int[10]>(a)  /* remove type annotation once type-checking complete */

    /* val arr[a[]] = input int[a[]] from alice  // bad */
    val c@Local(host = alice), d@Local(host = alice) = basic<>(a, b)  /* no brackets bc passing entire arr */
    return
}

/*
 alice and bob have same signature
 commitments: one has committed and commitment
 */
/* fun basic(a: share<int>, b: share<int>, d:out<share>) { } */
