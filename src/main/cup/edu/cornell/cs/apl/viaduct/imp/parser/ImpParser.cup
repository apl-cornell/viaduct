import java.util.List;
import java.util.LinkedList;

import edu.cornell.cs.apl.viaduct.imp.ast.*;
import edu.cornell.cs.apl.viaduct.imp.ast.BinaryOperators.*;
import edu.cornell.cs.apl.viaduct.security.Label;
import edu.cornell.cs.apl.viaduct.security.Principal;

nonterminal ProgramNode program;
nonterminal ProgramNode.Builder declaration_list;
nonterminal List<StmtNode> stmt_list;
nonterminal StmtNode stmt, stmt_basic, block;
nonterminal ExpressionNode expr;
nonterminal ImpValue value;
nonterminal Label label, label_expr;
nonterminal Variable variable;
nonterminal Host host;
nonterminal ProcessName process_name;

terminal String IDENT, CAP_IDENT;
terminal Integer INT_LIT;
terminal TRUE, FALSE;

terminal COLON, ASSIGN;
terminal ASSERT, SEND, TO, RECV, FROM, IF, ELSE;
terminal HOST, PROCESS, PROTOCOL, IDEAL;

terminal NOT, ANDAND, OROR;
terminal EQ, NEQ, LT, LEQ, GT, GEQ;
terminal TOP, BOTTOM, OR, AND, RARROW, LARROW;

terminal PLUS;
// terminal PLUS, MINUS, TIMES, DIVIDE;

terminal DECLASSIFY, ENDORSE, DOWNGRADE;

terminal OPEN_BRACE, CLOSE_BRACE, SEMICOLON, OPEN_PAREN, CLOSE_PAREN, COMMA;

precedence left ANDAND, OROR, AND, OR;
precedence nonassoc EQ, NEQ, LT, LEQ, GT, GEQ;
precedence left PLUS;
precedence right NOT;
precedence left LARROW, RARROW, NOT;
precedence nonassoc OPEN_PAREN, CLOSE_PAREN;

start with program;


program ::=
    declaration_list:declarations {: RESULT = declarations.build(); :}
  ;

declaration_list ::=
    HOST host:host COLON label:trust SEMICOLON declaration_list:declarations {:
      declarations.addHost(host, trust);
      RESULT = declarations;
    :}

  | PROCESS process_name:processName block:block declaration_list:declarations {:
      declarations.addProcess(processName, block);
      RESULT = declarations;
    :}

  | /* empty */ {:
      RESULT = ProgramNode.builder();
  :}
  ;

stmt ::=
    stmt_basic:stmt SEMICOLON {:
      RESULT = stmt;
    :}

  | IF OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase ELSE block:elseCase {:
      RESULT = new IfNode(guard, thenCase, elseCase);
    :}

  | IF OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase {:
      RESULT = new IfNode(guard, thenCase);
    :}

  | block:block {:
      RESULT = block;
    :}
  ;

stmt_basic ::=
    variable:var COLON label:lab {:
      RESULT = new DeclarationNode(var, lab);
    :}

  | variable:var ASSIGN expr:e {:
      RESULT = new AssignNode(var, e);
    :}

  | SEND expr:e TO process_name:processName {:
      RESULT = new SendNode(processName, e);
    :}

  | variable:var LARROW RECV process_name:processName {:
      RESULT = new ReceiveNode(var, processName);
    :}

  | ASSERT expr:e {:
      RESULT = new AssertNode(e);
    :}
  ;

block ::=
    OPEN_BRACE stmt_list:slist CLOSE_BRACE {:
      RESULT = new BlockNode(slist);
    :}
  ;

stmt_list ::=
    stmt_list:slist stmt:s {:
      slist.add(s);
      RESULT = slist;
    :}

  | /* empty */ {:
        RESULT = new LinkedList<>();
    :}
  ;

expr ::=
    value:value {:
      RESULT = new LiteralNode(value);
    :}

  | variable:var {:
      RESULT = new ReadNode(var);
    :}

  | NOT expr:e {:
      RESULT = new NotNode(e);
    :}

  | expr:e1 OROR expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, Or.create(), e2);
    :}

  | expr:e1 ANDAND expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, And.create(), e2);
    :}

  | expr:e1 EQ expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, EqualTo.create(), e2);
    :}

  | expr:e1 NEQ expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e1, EqualTo.create(), e2));
    :}

  | expr:e1 LT expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, LessThan.create(), e2);
    :}

  | expr:e1 LEQ expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, LessThanOrEqualTo.create(), e2);
    :}

  | expr:e1 GT expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e2, LessThan.create(), e1));
    :}

  | expr:e1 GEQ expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e2, LessThanOrEqualTo.create(), e1));
    :}

  | expr:e1 PLUS expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, Plus.create(), e2);
    :}

  | DECLASSIFY OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | ENDORSE OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | DOWNGRADE OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | OPEN_PAREN expr:e CLOSE_PAREN {:
      RESULT = e;
    :}
  ;

value ::=
    TRUE {:
      RESULT = new BooleanValue(true);
    :}

  | FALSE {:
      RESULT = new BooleanValue(false);
    :}

  | INT_LIT:lit {:
      RESULT = new IntegerValue(lit);
    :}
  ;

label ::=
    OPEN_BRACE CLOSE_BRACE {: RESULT = Label.bottom(); :}

  | OPEN_BRACE label_expr:l CLOSE_BRACE {: RESULT = l; :}
  ;

label_expr ::=
    CAP_IDENT:id {: RESULT = new Label(new Principal(id)); :}

  | TOP {: RESULT = Label.top(); :}

  | BOTTOM {: RESULT = Label.bottom(); :}

  | label_expr:l1 OR label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 AND label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l RARROW {:
      RESULT = l.confidentiality();
    :}

  | label_expr:l LARROW {:
      RESULT = l.integrity();
    :}

  | OPEN_PAREN label_expr:l CLOSE_PAREN {:
      RESULT = l;
    :}
  ;

variable ::=
    IDENT:id  {: RESULT = new Variable(id); :}
  ;

host ::=
    IDENT:id {: RESULT = new Host(id); :}
  ;

process_name ::=
    IDENT:id {: RESULT = new ProcessName(id); :}
  ;
