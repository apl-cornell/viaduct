import java.util.List;
import java.util.LinkedList;

import edu.cornell.cs.apl.viaduct.imp.ast.*;
import edu.cornell.cs.apl.viaduct.imp.ast.BinaryOperators.*;
import edu.cornell.cs.apl.viaduct.security.Label;
import edu.cornell.cs.apl.viaduct.security.Principal;

nonterminal StmtNode program;
nonterminal List<StmtNode> stmt_list;
nonterminal StmtNode stmt, stmt_basic, block;
nonterminal ExpressionNode expr;
nonterminal ImpValue value;
nonterminal BinaryOperator binop;
nonterminal Label label, label_expr;
nonterminal Variable variable;
nonterminal Host host;

terminal String IDENT, CAP_IDENT;
terminal Integer INT_LIT;
terminal TRUE, FALSE;

terminal ASSERT;
terminal COLON, ASSIGN;
terminal IF, ELSE, SEND, TO, RECV, FROM, HOST;

terminal NOT, ANDAND, OROR;
terminal EQ, NEQ, LT, LEQ, GT, GEQ;
terminal TOP, BOTTOM, OR, AND, RARROW, LARROW;

terminal PLUS;
// terminal PLUS, MINUS, TIMES, DIVIDE;

terminal DECLASSIFY, ENDORSE, DOWNGRADE;

terminal OPEN_BRACE, CLOSE_BRACE, SEMICOLON, OPEN_PAREN, CLOSE_PAREN, COMMA;

terminal DEBUG_VALUE;

precedence left ANDAND, OROR;
precedence left PLUS, EQ, NEQ, LT, LEQ, GT, GEQ, LARROW, RARROW, AND, OR;
precedence left LARROW, RARROW, NOT;
precedence left OPEN_PAREN, CLOSE_PAREN;

start with program;


program ::=
    stmt_list:slist {: RESULT = new BlockNode(slist); :}
  ;

stmt ::=
    stmt_basic:stmt SEMICOLON {:
      RESULT = stmt;
    :}

  | IF OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase ELSE block:elseCase {:
      RESULT = new IfNode(guard, thenCase, elseCase);
    :}

  | IF OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase {:
      RESULT = new IfNode(guard, thenCase);
    :}

  | block:block {:
      RESULT = block;
    :}
  ;

stmt_basic ::=
    variable:var COLON label:lab {:
      RESULT = new DeclarationNode(var, lab);
    :}

  | variable:var ASSIGN expr:e {:
      RESULT = new AssignNode(var, e);
    :}

  | SEND expr:e TO host:host {:
      RESULT = new SendNode(host, e);
    :}

  | variable:var LARROW RECV host:host {:
      RESULT = new ReceiveNode(var, host);
    :}

  | DEBUG_VALUE OPEN_PAREN expr:debug_value CLOSE_PAREN variable:var LARROW RECV host:host {:
      RESULT = new ReceiveNode(var, host, debug_value);
    :}

  | ASSERT expr:e {:
      RESULT = new AssertNode(e);
    :}
  ;

block ::=
    OPEN_BRACE stmt_list:slist CLOSE_BRACE {:
      RESULT = new BlockNode(slist);
    :}
  ;

stmt_list ::=
    stmt_list:slist stmt:s {:
      slist.add(s);
      RESULT = slist;
    :}

  | /* empty */ {:
        RESULT = new LinkedList<>();
    :}
  ;

expr ::=
    value:value {:
      RESULT = new LiteralNode(value);
    :}

  | variable:var {:
      RESULT = new ReadNode(var);
    :}

  | NOT expr:e {:
      RESULT = new NotNode(e);
    :}

  | expr:e1 binop:binop expr:e2 {:
      RESULT = BinaryExpressionNode.create(e1, binop, e2);
    :}

  | expr:e1 NEQ expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e1, EqualTo.create(), e2));
    :}

  | expr:e1 GT expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e2, LessThan.create(), e1));
    :}

  | expr:e1 GEQ expr:e2 {:
      RESULT = new NotNode(BinaryExpressionNode.create(e2, LessThanOrEqualTo.create(), e1));
    :}

  | DECLASSIFY OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | ENDORSE OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | DOWNGRADE OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | OPEN_PAREN expr:e CLOSE_PAREN {:
      RESULT = e;
    :}
  ;

value ::=
    TRUE {:
      RESULT = new BooleanValue(true);
    :}

  | FALSE {:
      RESULT = new BooleanValue(false);
    :}

  | INT_LIT:ilit {:
      RESULT = new IntegerValue(ilit);
    :}
  ;

binop ::=
    OROR {:
      RESULT = Or.create();
    :}

  | ANDAND {:
      RESULT = And.create();;
    :}

  | EQ {:
      RESULT = EqualTo.create();;
    :}

  | LT {:
      RESULT = LessThan.create();;
    :}

  | LEQ {:
      RESULT = LessThanOrEqualTo.create();;
    :}

  | PLUS {:
      RESULT = Plus.create();
    :}
  ;

label ::=
    OPEN_BRACE CLOSE_BRACE {: RESULT = Label.bottom(); :}

  | OPEN_BRACE label_expr:l CLOSE_BRACE {: RESULT = l; :}
  ;

label_expr ::=
    CAP_IDENT:id {: RESULT = new Label(new Principal(id)); :}

  | TOP {: RESULT = Label.top(); :}

  | BOTTOM {: RESULT = Label.bottom(); :}

  | label_expr:l1 OR label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 AND label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l RARROW {:
      RESULT = l.confidentiality();
    :}

  | label_expr:l LARROW {:
      RESULT = l.integrity();
    :}

  | OPEN_PAREN label_expr:l CLOSE_PAREN {:
      RESULT = l;
    :}
  ;

variable ::=
    IDENT:id  {: RESULT = new Variable(id); :}
  ;

host ::=
    IDENT:id {: RESULT = new Host(id); :}
  ;
