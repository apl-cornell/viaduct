package edu.cornell.cs.apl.viaduct.imp.parsing;

import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList;

import edu.cornell.cs.apl.viaduct.imp.ast.*;
import edu.cornell.cs.apl.viaduct.imp.ast.types.*;
import edu.cornell.cs.apl.viaduct.imp.ast.values.*;
import edu.cornell.cs.apl.viaduct.imp.ast.DowngradeNode.DowngradeType;
import edu.cornell.cs.apl.viaduct.imp.ast.BinaryOperators.*;
import edu.cornell.cs.apl.viaduct.security.Label;
import edu.cornell.cs.apl.viaduct.security.Principal;


action code {:
    /** Generate source location information for a node given left and right character offsets. */
    private SourceRange location(int left, int right) {
        final SourceFile source = ((ImpLexer) getScanner()).getSourceFile();
        final SourcePosition start = SourcePosition.create(source, left);
        final SourcePosition end = SourcePosition.create(source, right);
        return SourceRange.create(start, end);
    }

    /** Construct a binary expression node with source location inferred from the arguments. */
    private BinaryExpressionNode binary(BinaryOperator op, ExpressionNode lhs, ExpressionNode rhs) {
        return BinaryExpressionNode.builder()
            .setOperator(op)
            .setLhs(lhs)
            .setRhs(rhs)
            .setSourceLocation(lhs.getSourceLocation().merge(rhs.getSourceLocation()))
            .build();
    }

    /**
     * Construct an assignment node that applies an operation with source location inferred from
     * the arguments.
     */
    private AssignNode opAssign(BinaryOperator op, ReferenceNode lhs, ExpressionNode rhs) {
        final ExpressionNode readLhs = ReadNode.builder()
            .setReference(lhs)
            .setSourceLocation(lhs)
            .build();
        final ExpressionNode compute = binary(op, readLhs, rhs);
        return AssignNode.builder()
            .setLhs(lhs)
            .setRhs(compute)
            .setSourceLocation(compute)
            .build();
    }


    /**
     * Create a downgrade node. From and to labels are determined based on whether the user
     * specified one or two labels.
     */
    private DowngradeNode downgrade(
        DowngradeType downgradeType,
        ExpressionNode e,
        Label first,
        Label second,
        SourceRange location) {

        Label from;
        Label to;
        if (second != null) {
            from = first;
            to = second;
        } else {
            from = null;
            to = first;
        }

        return DowngradeNode.builder()
            .setDowngradeType(downgradeType)
            .setExpression(e)
            .setFromLabel(from)
            .setToLabel(to)
            .setSourceLocation(location)
            .build();
    }
:}


nonterminal ProgramNode program;
nonterminal ProgramNode.Builder declaration_list;
nonterminal TopLevelDeclarationNode declaration;
nonterminal StatementNode stmt, stmt_basic;
nonterminal BlockNode block;
nonterminal BlockNode.Builder stmt_list;
nonterminal ReferenceNode reference;
nonterminal ExpressionNode expr;
nonterminal ImpValue value;
nonterminal Label label, label_expr, optional_label, optional_to;
nonterminal Variable variable;
nonterminal HostName host;
nonterminal ProcessName process_name;
nonterminal ImpBaseType type, optional_type;

terminal String IDENT, CAP_IDENT;
terminal Integer INT_LIT;
terminal TRUE, FALSE;

terminal INT, BOOL;

terminal COLON;
terminal ASSERT, SEND, TO, RECV, FROM, IF, ELSE, WHILE, FOR;
terminal HOST, PROCESS, PROTOCOL, IDEAL;

terminal NOT, ANDAND, OROR;
terminal EQ, EQEQ, NEQ, LT, LEQ, GT, GEQ, PLUSEQ, MINUSEQ, TIMESEQ;
terminal TOP, BOTTOM, OR, AND, RARROW, LARROW;
terminal SQCUP, SQCAP, WEDGE, VEE, JOIN, MEET;

terminal PLUS, MINUS, TIMES, PLUSPLUS, MINUSMINUS;
// terminal PLUS, MINUS, TIMES, DIVIDE;

terminal DECLASSIFY, ENDORSE, DOWNGRADE;
terminal LET;

terminal OPEN_BRACE, CLOSE_BRACE, OPEN_SQBRACE, CLOSE_SQBRACE, SEMICOLON, OPEN_PAREN, CLOSE_PAREN, COMMA;

precedence left ANDAND, OROR, AND, OR, SQCUP, SQCAP, WEDGE, VEE, JOIN, MEET;
precedence nonassoc EQEQ, NEQ, LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT;
precedence left LARROW, RARROW, NOT;
precedence nonassoc OPEN_PAREN, CLOSE_PAREN;

start with program;


program ::=
    declaration_list:declarations {:
      RESULT = declarations
          .setSourceLocation(location(declarationsleft, declarationsright))
          .build();
  :}
  ;

declaration_list ::=
    declaration_list:declarations declaration:declaration {:
      RESULT = declarations.add(declaration);
    :}

  | /* empty */ {:
      RESULT = ProgramNode.builder();
  :}
  ;

declaration ::=
    HOST:begin host:host COLON label:trust SEMICOLON:end {:
      RESULT = HostDeclarationNode.builder()
          .setName(host)
          .setTrust(trust)
          .setSourceLocation(location(beginleft, endright))
          .build();
    :}

  | PROCESS:begin process_name:processName block:body {:
      RESULT = ProcessDeclarationNode.builder()
          .setName(processName)
          .setBody(body)
          .setSourceLocation(location(beginleft, bodyright))
          .build();
    :}
  ;


stmt ::=
    stmt_basic:stmt SEMICOLON {:
      RESULT = stmt;
    :}

  | IF:begin OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase ELSE block:elseCase {:
      RESULT = IfNode.builder()
          .setGuard(guard)
          .setThenBranch(thenCase)
          .setElseBranch(elseCase)
          .setSourceLocation(location(beginleft, elseCaseright))
          .build();
    :}

  | IF:begin OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase {:
      RESULT = IfNode.builder()
          .setGuard(guard)
          .setThenBranch(thenCase)
          .setSourceLocation(location(beginleft, thenCaseright))
          .build();
    :}

  | WHILE:begin OPEN_PAREN expr:guard CLOSE_PAREN block:body {:
      RESULT = WhileNode.builder()
          .setGuard(guard)
          .setBody(body)
          .setSourceLocation(location(beginleft, bodyright))
          .build();
    :}

  | FOR:begin OPEN_PAREN stmt_basic:initializer SEMICOLON expr:guard SEMICOLON stmt_basic:update CLOSE_PAREN block:body {:
      RESULT = ForNode.builder()
          .setInitialize(initializer)
          .setGuard(guard)
          .setUpdate(update)
          .setBody(body)
          .setSourceLocation(location(beginleft, bodyright))
          .build();
    :}

  | block:block {:
      RESULT = block;
    :}
  ;

stmt_basic ::=
    type:ty optional_label:lab variable:var {:
      RESULT = VariableDeclarationNode.builder()
          .setVariable(var)
          .setType(ty)
          .setLabel(lab)
          .setSourceLocation(location(tyleft, varright))
          .build();
    :}

//  | type:ty label:lab variable:var EQ expr:e {:
//      List<StatementNode> stmts = new ArrayList<>();
//      stmts.add(VariableDeclarationNode.create(var, ty, lab));
//      stmts.add(AssignNode.create(var, e));
//      RESULT = BlockNode.create(stmts);
//    :}

  | type:ty optional_label:lab variable:var OPEN_SQBRACE expr:e CLOSE_SQBRACE:end {:
      RESULT = ArrayDeclarationNode.builder()
          .setVariable(var)
          .setLength(e)
          .setElementType(ty)
          .setLabel(lab)
          .setSourceLocation(location(tyleft, endright))
          .build();
    :}

  | LET:begin variable:var EQ expr:e {:
      RESULT = LetBindingNode.builder()
          .setVariable(var)
          .setRhs(e)
          .setSourceLocation(location(beginleft, eright))
          .build();
    :}

  | reference:ref EQ expr:e {:
      RESULT = AssignNode.builder()
          .setLhs(ref)
          .setRhs(e)
          .setSourceLocation(location(refleft, eright))
          .build();
    :}

  | reference:ref PLUSEQ expr:e {:
      RESULT = opAssign(Plus.create(), ref, e);
    :}

  | reference:ref MINUSEQ expr:e {:
      RESULT = opAssign(Minus.create(), ref, e);
    :}

  | reference:ref TIMESEQ expr:e {:
      RESULT = opAssign(Times.create(), ref, e);
    :}

  | SEND:begin expr:e TO process_name:recipient {:
      RESULT = SendNode.builder()
          .setRecipient(recipient)
          .setSentExpression(e)
          .setSourceLocation(location(beginleft, recipientright))
          .build();
    :}

  | variable:var LARROW RECV optional_type:ty process_name:sender {:
      RESULT = ReceiveNode.builder()
          .setVariable(var)
          .setReceiveType(ty)
          .setSender(sender)
          .setSourceLocation(location(varleft, senderright))
          .build();
    :}

  | ASSERT:begin expr:e {:
      RESULT = AssertNode.builder()
          .setExpression(e)
          .setSourceLocation(location(beginleft, eright))
          .build();
    :}
  ;

block ::=
    OPEN_BRACE:begin stmt_list:slist CLOSE_BRACE:end {:
      RESULT = slist.setSourceLocation(location(beginleft, endright)).build();
    :}
  ;

stmt_list ::=
    stmt_list:slist stmt:s {:
      RESULT = slist.add(s);
    :}

  | /* empty */ {:
      RESULT = BlockNode.builder();
    :}
  ;


reference ::=
    variable:var OPEN_SQBRACE expr:e CLOSE_SQBRACE:end {:
      RESULT = ArrayIndexingNode.builder()
          .setArray(var)
          .setIndex(e)
          .setSourceLocation(location(varleft, endright))
          .build();
    :}

  | variable:var {:
      RESULT = var;
    :}
  ;


expr ::=
    value:value {:
      RESULT = LiteralNode.builder()
          .setValue(value)
          .setSourceLocation(location(valueleft, valueright))
          .build();
    :}

  | reference:ref {:
       RESULT = ReadNode.builder().setReference(ref).setSourceLocation(ref).build();
    :}

  | NOT:begin expr:e {:
      RESULT = NotNode.builder()
          .setExpression(e)
          .setSourceLocation(location(beginleft, eright))
          .build();
    :}

  | expr:e1 ANDAND expr:e2 {:
      RESULT = binary(And.create(), e1, e2);
    :}

  | expr:e1 OROR expr:e2 {:
      RESULT = binary(Or.create(), e1, e2);
    :}

  | expr:e1 EQEQ expr:e2 {:
      RESULT = binary(EqualTo.create(), e1, e2);
    :}

  | expr:e1 NEQ expr:e2 {:
      final ExpressionNode eq = binary(EqualTo.create(), e1, e2);
      RESULT = NotNode.builder()
          .setExpression(eq)
          .setSourceLocation(eq)
          .build();
    :}

  | expr:e1 LT expr:e2 {:
      RESULT = binary(LessThan.create(), e1, e2);
    :}

  | expr:e1 LEQ expr:e2 {:
      RESULT = binary(LessThanOrEqualTo.create(), e1, e2);
    :}

  | expr:e1 GT expr:e2 {:
      RESULT = binary(LessThan.create(), e2, e1);
    :}

  | expr:e1 GEQ expr:e2 {:
      RESULT = binary(LessThanOrEqualTo.create(), e2, e1);
    :}

  | expr:e1 PLUS expr:e2 {:
      RESULT = binary(Plus.create(), e1, e2);
    :}

  | expr:e1 MINUS expr:e2 {:
      RESULT = binary(Minus.create(), e1, e2);
    :}

  | expr:e1 TIMES expr:e2 {:
      RESULT = binary(Times.create(), e1, e2);
    :}

  | MINUS:begin expr:e {:
      final LiteralNode zero = LiteralNode.builder()
          .setValue(IntegerValue.create(0))
          .setSourceLocation(location(beginleft, beginright))
          .build();
      RESULT = binary(Minus.create(), zero, e);
    :}

  | DECLASSIFY:begin OPEN_PAREN expr:e COMMA label:first optional_to:second CLOSE_PAREN:end {:
      RESULT = downgrade(DowngradeType.DECLASSIFY, e, first, second, location(beginleft, endright));
    :}

  | ENDORSE:begin OPEN_PAREN expr:e COMMA label:first optional_to:second CLOSE_PAREN:end {:
      RESULT = downgrade(DowngradeType.ENDORSE, e, first, second, location(beginleft, endright));
    :}

  | DOWNGRADE:begin OPEN_PAREN expr:e COMMA label:first optional_to:second CLOSE_PAREN:end {:
      RESULT = downgrade(DowngradeType.BOTH, e, first, second, location(beginleft, endright));
    :}

  | OPEN_PAREN expr:e CLOSE_PAREN {:
      RESULT = e;
    :}
  ;

value ::=
    TRUE {:
      RESULT = BooleanValue.create(true);
    :}

  | FALSE {:
      RESULT = BooleanValue.create(false);
    :}

  | INT_LIT:lit {:
      RESULT = IntegerValue.create(lit);
    :}
  ;


optional_type ::=
    type:ty {:
        RESULT = ty;
    :}
  | /* nothing */ {:
        RESULT = null;
    :}
  ;

optional_label ::=
    label:l {:
        RESULT = l;
    :}
  | /* nothing */ {:
        RESULT = null;
    :}
  ;

optional_to ::=
    TO label:l {:
        RESULT = l;
    :}
  | /* nothing */ {:
        RESULT = null;
    :}
  ;


type ::=
    INT {: RESULT = IntegerType.create(); :}
  | BOOL {: RESULT = BooleanType.create(); :}
  ;


label ::=
    OPEN_BRACE label_expr:l CLOSE_BRACE {: RESULT = l; :}
  ;

label_expr ::=
    CAP_IDENT:id {: RESULT = new Label(Principal.create(id)); :}

  | TOP {: RESULT = Label.weakest(); :}

  | BOTTOM {: RESULT = Label.strongest(); :}

  | label_expr:l1 OR label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 VEE label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 AND label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 WEDGE label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 SQCUP label_expr:l2 {:
      RESULT = l1.join(l2);
    :}

  | label_expr:l1 JOIN label_expr:l2 {:
      RESULT = l1.join(l2);
    :}

  | label_expr:l1 SQCAP label_expr:l2 {:
      RESULT = l1.meet(l2);
    :}

  | label_expr:l1 MEET label_expr:l2 {:
      RESULT = l1.meet(l2);
    :}

  | label_expr:l RARROW {:
      RESULT = l.confidentiality();
    :}

  | label_expr:l LARROW {:
      RESULT = l.integrity();
    :}

  | OPEN_PAREN label_expr:l CLOSE_PAREN {:
      RESULT = l;
    :}
  ;


variable ::=
    IDENT:id  {:
      RESULT = Variable.builder()
          .setName(id)
          .setSourceLocation(location(idleft, idright))
          .build();
  :}
  ;

host ::=
    // TODO: add source location
    IDENT:id {: RESULT = HostName.create(id); :}
  ;

process_name ::=
    // TODO: add source location
    IDENT:id {: RESULT = ProcessName.create(id); :}
  ;
