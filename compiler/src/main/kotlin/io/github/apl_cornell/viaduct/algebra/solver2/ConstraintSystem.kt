package io.github.apl_cornell.viaduct.algebra.solver2

import io.github.apl_cornell.viaduct.algebra.BoundedLattice
import io.github.apl_cornell.viaduct.algebra.HeytingAlgebra
import io.github.apl_cornell.viaduct.algebra.LatticeCongruence
import io.github.apl_cornell.viaduct.algebra.PartialOrder
import io.github.apl_cornell.viaduct.util.Colors
import io.github.apl_cornell.viaduct.util.dataflow.DataFlowEdge
import io.github.apl_cornell.viaduct.util.dataflow.solveDataFlow
import org.jgrapht.Graph
import org.jgrapht.graph.DirectedPseudograph
import org.jgrapht.nio.Attribute
import org.jgrapht.nio.DefaultAttribute
import org.jgrapht.nio.dot.DOTExporter
import java.io.Writer

/**
 * Given a set of constraints, finds the unique maximum solution if it exists.
 *
 * A solution to a set of constraints is an assignment of values to all variables in the system.
 * A maximum solution assigns the greatest possible value to each variable, where greatest is with
 * respect to [PartialOrder.lessThanOrEqualTo].
 *
 * @param C type of lattice constants
 * @param V type of variables
 * @param T type of exceptions thrown when there are unsatisfiable constraints
 *
 * @param constraints The set of constraints to solve.
 */
class ConstraintSystem<C : HeytingAlgebra<C>, V, T : Throwable>(
    constraints: Iterable<Constraint<C, V, T>>,
    bounds: BoundedLattice<C>,
    private val delegationContext: LatticeCongruence<C>
) {
    /**
     * Represents constraints as a graph. Each vertex is an atomic term (a constant or a variable),
     * and an edge from term `t2` to `t1` corresponds to the constraint `t1 â‰¤ f(t2)` where `f` is
     * a function determined by the edge.
     *
     * Note that edges point from right-hand vertices to the left-hand vertices since we are
     * solving for the greatest solution.
     */
    private val constraintGraph =
        DirectedPseudograph<AtomicTerm<C, V>, DataFlowEdge<C>>(null, null, false).apply {
            constraints.forEach { constraint ->
                when (constraint) {
                    is FlowsToConstraint ->
                        constraint.reducedForm.forEach { this.addEdgeWithVertices(it.to, it.from, it.propagate) }
                }
            }
        }

    /**
     * The greatest solution to the set of constraints in the system if there is a unique one.
     * Some constraints will be violated by the solution if there is no unique solution.
     */
    private val bestEffortSolution: ConstraintSolution<C, V> = run {
        // Use data flow analysis to find a solution for all nodes.
        val solution = solveDataFlow(bounds.top, constraintGraph)

        // Restrict the mapping to only contain variables.
        val variableAssignment = mutableMapOf<V, C>()
        for ((key, value) in solution) {
            if (key is Variable) {
                variableAssignment[key.value] = value
            }
        }

        ConstraintSolution(variableAssignment, bounds.top)
    }

    /** List of exceptions generated by unsatisfied constraints. */
    private val unsatisfiedConstraints: List<T> =
        constraints.mapNotNull {
            when (it) {
                is FlowsToConstraint -> {
                    val from = bestEffortSolution.evaluate(it.from)
                    val to = bestEffortSolution.evaluate(it.to)
                    if (!delegationContext.lessThanOrEqualTo(from, to)) it.failWith(from, to) else null
                }
            }
        }

    /**
     * Returns the greatest solution to the set of constraints in the system.
     *
     * @throws T if there are unsatisfiable constraints.
     */
    fun solution(): ConstraintSolution<C, V> {
        if (unsatisfiedConstraints.isNotEmpty()) {
            throw unsatisfiedConstraints.first()
        }
        return bestEffortSolution
    }

    /** Returns whether the constraint represented by [edge] is satisfied by [bestEffortSolution]. */
    private fun constraintSatisfied(edge: DataFlowEdge<C>): Boolean {
        val sourceValue = bestEffortSolution.evaluate(constraintGraph.getEdgeSource(edge))
        val targetValue = bestEffortSolution.evaluate(constraintGraph.getEdgeTarget(edge))
        return delegationContext.lessThanOrEqualTo(targetValue, edge.propagate(sourceValue))
    }

    /** Outputs the constraint system as a DOT graph to [writer]. */
    fun exportDotGraph(writer: Writer) {
        val dotExporter = DOTExporter<AtomicTerm<C, V>, DataFlowEdge<C>>()

        // Vertex labels and shape
        dotExporter.setVertexAttributeProvider { vertex: AtomicTerm<C, V> ->
            val attributes = mutableMapOf<String, Attribute>()

            // Include solution in the label for variables.
            attributes["label"] = DefaultAttribute.createAttribute(
                if (vertex is Variable)
                    "$vertex\\n{${bestEffortSolution.evaluate(vertex)}}"
                else
                    vertex.toString()
            )

            // Differentiate constant vertices from variable vertices.
            attributes["color"] = DefaultAttribute.createAttribute(Colors.BLACK)
            attributes["fontcolor"] = DefaultAttribute.createAttribute(Colors.BLACK)
            if (vertex is Constant) {
                attributes["color"] = DefaultAttribute.createAttribute(Colors.GRAY)
                attributes["style"] = DefaultAttribute.createAttribute("filled")
            }
            attributes
        }

        // Edge labels and shape
        dotExporter.setEdgeAttributeProvider { edge: DataFlowEdge<C> ->
            // Highlight edges that represent violated constraints
            val color = when {
                !constraintSatisfied(edge) ->
                    Colors.RED

                edge is IdentityEdge ->
                    Colors.BLACK

                else ->
                    Colors.BLUE
            }
            mapOf(
                "label" to DefaultAttribute.createAttribute(edge.toString()),
                "color" to DefaultAttribute.createAttribute(color),
                "fontcolor" to DefaultAttribute.createAttribute(color)
            )
        }

        dotExporter.exportGraph(constraintGraph, writer)
    }

    companion object {
        /** Adds [edge] between [source] and [target], automatically adding the vertices to the graphs if necessary. */
        private fun <V, E> Graph<V, E>.addEdgeWithVertices(source: V, target: V, edge: E) {
            addVertex(source)
            addVertex(target)
            addEdge(source, target, edge)
        }
    }
}
