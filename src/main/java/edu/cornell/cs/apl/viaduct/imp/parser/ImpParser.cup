package edu.cornell.cs.apl.viaduct.imp.parser;

import java.util.ArrayList;
import java.util.List;

import edu.cornell.cs.apl.viaduct.imp.ast.*;
import edu.cornell.cs.apl.viaduct.security.Label;
import edu.cornell.cs.apl.viaduct.security.Principal;

// You might want to add types to these declarations.
terminal String IDENT, CAP_IDENT;
terminal Integer INT_LIT;
terminal String ANNOTATION;
terminal TRUE, FALSE;

// terminal PLUS, MINUS, TIMES, DIVIDE;
terminal PLUS;
terminal LT, LEQ, GT, GEQ, AND, ANDAND, OR, OROR, EQ, NEQ, NOT;
terminal RARROW, LARROW, ASSIGN;
terminal OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE, SEMICOLON, COLON, COMMA;
terminal TOP, BOTTOM;
terminal IF, ELSE, SEND, RECV, TO, FROM, SKIP, DECLASSIFY, ENDORSE;

nonterminal StmtNode program;
nonterminal List<StmtNode> stmt_list;
nonterminal StmtNode stmt_basic, stmt_complex, block;
nonterminal ExpressionNode expr;
nonterminal Label label, label_expr;

precedence left PLUS, EQ, NEQ, LT, LEQ, GT, GEQ, ANDAND, OROR, LARROW, RARROW, AND, OR;
precedence left LARROW, RARROW, NOT;
precedence left OPEN_PAREN, CLOSE_PAREN;

start with program;

program ::=
    block:b {: RESULT = b; :}
  ;

block ::=
    stmt_list:slist {: RESULT = new BlockNode(slist); :}
  ;

stmt_list ::=
    stmt_basic:s SEMICOLON {:
      ArrayList<StmtNode> slist = new ArrayList<>();
      slist.add(s);
      RESULT = slist;
    :}

  | stmt_complex:s {:
      ArrayList<StmtNode> slist = new ArrayList<>();
      slist.add(s);
      RESULT = slist;
    :}

  | stmt_list:slist stmt_basic:s SEMICOLON {:
      slist.add(s);
      RESULT = slist;
    :}

  | stmt_list:slist stmt_complex:s {:
      slist.add(s);
      RESULT = slist;
    :}
  ;

stmt_basic ::=
    IDENT:idv COLON label:lab {:
      Variable var = new Variable(idv);
      RESULT = new VarDeclNode(var, lab);
    :}

  | IDENT:idv ASSIGN expr:e {:
      Variable var = new Variable(idv);
      RESULT = new AssignNode(var, e);
    :}

  | SEND expr:e TO IDENT:idv {:
      RESULT = new SendNode(idv, e);
    :}

  | IDENT:idv LARROW RECV FROM IDENT:idp {:
      Variable var = new Variable(idv);
      RESULT = new RecvNode(idp, var);
    :}

  | SKIP {: RESULT = new SkipNode(); :}
  ;

stmt_complex ::=
    IF OPEN_PAREN expr:guard CLOSE_PAREN OPEN_BRACE block:bthen CLOSE_BRACE
    ELSE OPEN_BRACE block:belse CLOSE_BRACE {:
      RESULT = new IfNode(guard, bthen, belse);
    :}

  | IF OPEN_PAREN expr:guard CLOSE_PAREN OPEN_BRACE block:bthen CLOSE_BRACE {:
      RESULT = new IfNode(guard, bthen, new SkipNode());
    :}

  | ANNOTATION:annot {:
      RESULT = new AnnotationNode(annot);
    :}
  ;

expr ::=
    INT_LIT:ilit {:
      RESULT = new IntegerLiteralNode(ilit);
    :}

  | IDENT:id {:
      RESULT = new ReadNode(new Variable(id));
    :}

  | TRUE {:
      RESULT = new BooleanLiteralNode(true);
    :}

  | FALSE {:
      RESULT = new BooleanLiteralNode(false);
    :}

  | expr:e1 PLUS expr:e2 {:
      RESULT = new PlusNode(e1, e2);
    :}

  | expr:e1 OROR expr:e2 {:
      RESULT = new OrNode(e1, e2);
    :}

  | expr:e1 ANDAND expr:e2 {:
      RESULT = new AndNode(e1, e2);
    :}

  | expr:e1 LT expr:e2 {:
      RESULT = new LessThanNode(e1, e2);
    :}

  | expr:e1 LEQ expr:e2 {:
      RESULT = new LeqNode(e1, e2);
    :}

  | expr:e1 GT expr:e2 {:
      RESULT = new NotNode(new LeqNode(e1, e2));
    :}

  | expr:e1 GEQ expr:e2 {:
      RESULT = new NotNode(new LessThanNode(e1, e2));
    :}

  | expr:e1 EQ expr:e2 {:
      RESULT = new EqualNode(e1, e2);
    :}

  | expr:e1 NEQ expr:e2 {:
      RESULT = new NotNode(new EqualNode(e1, e2));
    :}

  | NOT expr:e {:
      RESULT = new NotNode(e);
    :}

  | DECLASSIFY OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | ENDORSE OPEN_PAREN expr:e COMMA label:l CLOSE_PAREN {:
      RESULT = new DowngradeNode(e, l);
    :}

  | OPEN_PAREN expr:e CLOSE_PAREN {:
      RESULT = e;
    :}
  ;

label ::=
    OPEN_BRACE CLOSE_BRACE {: RESULT = Label.bottom(); :}

  | OPEN_BRACE label_expr:l CLOSE_BRACE {: RESULT = l; :}
  ;

label_expr ::=
    CAP_IDENT:id {: RESULT = new Label(new Principal(id)); :}

  | BOTTOM {: RESULT = Label.bottom(); :}

  | TOP {: RESULT = Label.top(); :}

  | label_expr:l1 AND label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 OR label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l RARROW {:
      RESULT = l.confidentiality();
    :}

  | label_expr:l LARROW {:
      RESULT = l.integrity();
    :}

  | OPEN_PAREN label_expr:l CLOSE_PAREN {:
      RESULT = l;
    :}
  ;
