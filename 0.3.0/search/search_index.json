{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Viaduct","text":"<p>Viaduct is an extensible, optimizing compiler for secure distributed programs. It lets developers write programs in a simple sequential language that embeds high-level security policies using information flow labels. Viaduct then compiles the source program into a distributed implementation that employs cryptography to defend the security policy.</p> <p>Viaduct is extensible: it provides a set of well-defined interfaces that developers can implement to add support for new cryptographic mechanisms. Because of its novel design, Viaduct does not place limitations on the source programs it can compile, such as the number of participants or trust assumptions between participants. Viaduct uses a cost model to generate efficient distributed programs, avoiding the use of expensive cryptography unless necessary.</p> <p>Our prototype compiler and runtime, written in Kotlin, can be found on Github. It currently supports the following cryptographic mechanisms:</p> <ul> <li>multiparty computation (via ABY)</li> <li>zero-knowledge proofs (via libsnark)</li> <li>commitments (SHA256 hash + nonce)</li> </ul> <p>More details about the compiler can be found in our PLDI 2021 paper.</p>"},{"location":"developer-guide/building/","title":"Building","text":"<p>We use Gradle for builds. You do not have to install Gradle manually; you only need to have Java available.</p> <p>Once you have Java installed, just run</p> <pre><code>./gradlew build\n</code></pre> <p>to build the code. This will also run all tests, so if this command works, you are good to go.</p> <p>On Unix environments, you can run the compiler using <code>./viaduct</code> from project root. This will use Gradle to automatically rebuild the application as necessary, so you do not have to worry about calling <code>./gradlew build</code> each time you change something. To start, try</p> <pre><code>./viaduct --help\n</code></pre>"},{"location":"developer-guide/building/#building-back-ends","title":"Building back ends","text":""},{"location":"developer-guide/building/#aby","title":"ABY","text":"<p>We use ABY for our secure multiparty computation back end. We have bundled ABY as a Java library (see aby-java), so no additional setup is necessary to make it work.</p> <p>Warning</p> <p>aby-java currently does not support Windows.</p>"},{"location":"developer-guide/building/#libsnark","title":"libsnark","text":"<p>We use libsnark for our zero-knowledge proofs back end. You have to manually build the JNI wrapper for libsnark to use the ZKP back end.</p> <p>First, clone <code>libfqfft</code>: https://github.com/scipr-lab/libfqfft. <code>libsnark</code> actually depends on this library, but we have to build it ourselves because we need to set the <code>-fPIC</code> flag manually to get the wrapper to build. To build, navigate to the root of the repository and run this on your shell: <code>mkdir build &amp;&amp; cd build &amp;&amp; cmake -DCMAKE_POSITION_INDEPENDENT_CODE=ON ..</code>. Then run <code>make</code> and then <code>make install</code> to install the libraries and header files.</p> <p>Next, clone <code>libsnark</code>: https://github.com/scipr-lab/libsnark. Run this command in the root of the repository: <code>mkdir build &amp;&amp; cd build &amp;&amp; cmake -DUSE_LINKED_LIBRARIES=ON ..</code>. The <code>cmake</code> flag makes the build use the installed version of <code>libfqfft</code> instead of building it again in the <code>depends</code> subrepository. Then run <code>make</code> and then <code>make install</code> to install the libraries and header files.</p> <p>Finally, build the <code>libsnark</code> wrapper. Navigate to this directory of the <code>viaduct</code> repository: <code>runtime/src/main/cwrapper</code>. Next, inspect the <code>Makefile</code> and make sure that the <code>INCLUDES</code> variable points to the JVM directories. Then inspect the <code>libsnarkwrapper.so</code> target and make sure the link directory (<code>-L</code>) points to the directory where <code>libff</code> and <code>libsnark</code> were installed. Run <code>make</code> to build <code>libsnarkwrapper.</code> Finally, run <code>make install</code> to install the wrapper in a directory known by the JVM to include JNI libraries. By default, the <code>install</code> target will copy the wrapper in <code>/usr/lib/</code>.</p>"},{"location":"developer-guide/documentation/","title":"Updating Documentation","text":"<p>We use MkDocs to generate documentation. See:</p> <ul> <li>mkdocs documentation.</li> <li>mkdocs-material documentation.</li> </ul>"},{"location":"developer-guide/documentation/#project-layout","title":"Project layout","text":"<pre><code>docs/\n    mkdocs.yml    # The configuration file.\n    src/\n        index.md  # The documentation homepage.\n        ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"developer-guide/documentation/#gradle-tasks","title":"Gradle tasks","text":"<ul> <li><code>mkdocsBuild</code> - Build the documentation site.</li> <li><code>mkdocsServe --no-daemon</code> - Start the live-reloading docs server.</li> </ul>"},{"location":"developer-guide/logging/","title":"Logging","text":"<p>We use the kotlin-logging library for showing additional information to the user. Logs go to standard error in accordance with Unix conventions, and the user can control the granularity of logs using the <code>--verbose</code> flag.</p> <p>As a general rule, never use <code>print()</code> or <code>println()</code> to display information to the user. This includes showing information to yourself for debugging. All logging frameworks have a <code>DEGUB</code> level, and if you found this information useful, chances are it will be relevant later.</p> <p>Logging is extremely easy to use. See this section of the Kotlin library.</p>"},{"location":"user-guide/compiling-and-running/","title":"Using the Compiler","text":"<p>There are two main compiler commands you need to know. The <code>compile</code> command compiles Viaduct source programs into distributed programs. The <code>run</code> command allows hosts to execute a compiled distributed program together. We will go over the basics of using these two commands in the following sections. You can run <code>viaduct compile --help</code> and <code>viaduct run --help</code> to get more information about each of these commands and the various options and flags they support.</p>"},{"location":"user-guide/compiling-and-running/#compiling-source-programs","title":"Compiling Source Programs","text":"<p>As an example, we will compile the <code>examples/Millionaires.via</code> program, which is an implementation of the standard Millionaires' problem in Viaduct. You can view the source program with the following command:</p> <pre><code>less examples/Millionaires.via\n</code></pre> <p>Note that this and other programs in the <code>examples</code> directory are purposefully simple; you can find more complex examples under the <code>benchmarks</code> directory. Run the following to compile the program:</p> <pre><code>viaduct -v compile examples/Millionaires.via\n</code></pre> <p>This will print the compiled program to the standard output. The <code>-v</code> option turns on detailed logging, and must come before the command name (e.g., <code>viaduct compile -v</code> will not work). You can repeat it (e.g., <code>-vvv</code>) for more granular messages, or leave it out.</p> <p>To save the compiled file to disk, provide the <code>-o</code> option along with a file name:</p> <pre><code>viaduct -v compile examples/Millionaires.via -o m-out.via\n</code></pre> <p>You should see logging information that looks like this:</p> <pre><code>1015 ms [main] INFO  Compile - elaborating source program...\n1110 ms [main] INFO  Compile - specializing functions...\n1115 ms [main] INFO  Check - name analysis...\n1149 ms [main] INFO  Check - type checking...\n1159 ms [main] INFO  Check - out parameter initialization analysis...\n1165 ms [main] INFO  Check - information flow analysis...\n1251 ms [main] INFO  InformationFlowAnalysis - number of label variables: 28\n1251 ms [main] INFO  Check - finished information flow analysis, ran for 87ms\n1272 ms [main] INFO  Compile - selecting protocols...\n1779 ms [main] INFO  Z3Selection - number of symvars: 91\n1779 ms [main] INFO  Z3Selection - cost mode set to MINIMIZE\n1828 ms [main] INFO  Z3Selection - constraints satisfiable, extracted model\n1834 ms [main] INFO  Compile - finished protocol selection, ran for 519ms\n1842 ms [main] INFO  Compile - annotating program with protocols...\n</code></pre> <p>You can view the compiled program:</p> <pre><code>less m-out.via\n</code></pre> <p>Notice that the compiled program is an elaborated version of the source program where each variable declaration and let binding is annotated with the protocol that will execute it.</p>"},{"location":"user-guide/compiling-and-running/#running-compiled-programs","title":"Running Compiled Programs","text":"<p>The <code>run</code> command takes as arguments a host name and a compiled program, and executes the host's \"projection\" of the distributed program. Since compiled programs are distributed, we need to run multiple instances of Viaduct. For instance, to execute our example program <code>m-out.via</code>, we need two participants standing in for hosts <code>alice</code> and <code>bob</code>, respectively.</p> <p>The easiest way to accomplish this from the single terminal window we have is to run one of the commands in the background:</p> <pre><code>viaduct -v run alice m-out.via -in inputs/alice.txt &amp;\nviaduct -v run bob m-out.via -in inputs/bob.txt\n</code></pre> <p>Here, we run two instances with logging enabled (the <code>-v</code> option), and provide inputs from files (<code>-in FILENAME</code>).</p> <p>An alternative to running one of the instances in the background is using Tmux and running each participant in a different pane. This method allows you to manually provide input to each participant. However, we only recommend this alternative if you are already familiar with Tmux (or are willing to pick up the basics). Here is a very quick tutorial to get you started:</p> <ol> <li> <p>Start a new session by typing <code>tmux</code>.</p> </li> <li> <p>Split your terminal using the keyboard shortcut <code>Ctrl+b \"</code>.</p> </li> <li> <p>Switch between panes using <code>Ctrl+b &lt;arrow key&gt;</code> (up and down keys specifically).</p> </li> <li> <p>Execute the following two commands in separate panes:    <pre><code>viaduct run alice m-out.via -in inputs/alice.txt\nviaduct run bob m-out.via -in inputs/bob.txt\n</code></pre></p> </li> </ol> <p>We recommend starting Alice's process first; you may get a \"connection timed out\"    error otherwise.</p> <ol> <li>Quit Tmux by typing <code>tmux kill-session</code>.</li> </ol> <p>You can provide input manually for one or both of the participants by omitting the <code>-in</code> option (we also recommend leaving out the <code>-v</code> option). The participant will block on an <code>Input:</code> prompt when you need to provide input.</p> <p>You can repeat these steps for the other programs in the <code>examples</code> and <code>benchmarks</code> directories. However, programs in the <code>benchmarks</code> directory expect many (sometimes hundreds) of inputs, so we don't recommend providing inputs by hand!</p>"},{"location":"user-guide/compiling-and-running/#editing-files","title":"Editing files","text":"<p>You can edit files using the <code>nano</code> editor:</p> <pre><code>nano examples/Millionaires.via\n</code></pre>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>The easiest way to try out Viaduct is by using Docker. After installing Docker, run the following in a terminal:</p> <pre><code>docker run --rm -it aplcornell/viaduct\n</code></pre> <p>This will drop you in a Docker container that has the Viaduct compiler installed. To get started, try</p> <pre><code>viaduct --help\n</code></pre> <p>To build Viaduct from source code, refer to the Developer's Guide.</p>"}]}