package edu.cornell.cs.apl.viaduct.imp.parsing;

import com.google.common.collect.ImmutableList;

import edu.cornell.cs.apl.viaduct.errors.ParsingError;
import edu.cornell.cs.apl.viaduct.imp.ast.*;
import edu.cornell.cs.apl.viaduct.imp.ast.types.*;
import edu.cornell.cs.apl.viaduct.imp.ast.values.*;
import edu.cornell.cs.apl.viaduct.imp.ast.DowngradeNode.DowngradeType;
import edu.cornell.cs.apl.viaduct.imp.ast.BinaryOperators.*;
import edu.cornell.cs.apl.viaduct.security.Label;
import edu.cornell.cs.apl.viaduct.security.Principal;

import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList;

import java_cup.runtime.Symbol;


action code {:
    /** Construct a binary expression node with source location inferred from the arguments. */
    private BinaryExpressionNode binary(BinaryOperator op, ExpressionNode lhs, ExpressionNode rhs) {
        return BinaryExpressionNode.builder()
            .setOperator(op)
            .setLhs(lhs)
            .setRhs(rhs)
            .setSourceLocation(lhs.getSourceLocation().merge(rhs.getSourceLocation()))
            .build();
    }

    /**
     * Construct an assignment node that applies an operation with source location inferred from
     * the arguments.
     */
    private AssignNode opAssign(BinaryOperator op, ReferenceNode lhs, ExpressionNode rhs) {
        final ExpressionNode readLhs = ReadNode.builder()
            .setReference(lhs)
            .setSourceLocation(lhs)
            .build();
        final ExpressionNode compute = binary(op, readLhs, rhs);
        return AssignNode.builder()
            .setLhs(lhs)
            .setRhs(compute)
            .setSourceLocation(compute)
            .build();
    }


    /**
     * Create a downgrade node. From and to labels are determined based on whether the user
     * specified one or two labels.
     */
    private DowngradeNode downgrade(
        DowngradeType downgradeType,
        ExpressionNode e,
        Label first,
        Label second,
        SourceRange location) {

        Label from;
        Label to;
        if (second != null) {
            from = first;
            to = second;
        } else {
            from = null;
            to = first;
        }

        return DowngradeNode.builder()
            .setDowngradeType(downgradeType)
            .setExpression(e)
            .setFromLabel(from)
            .setToLabel(to)
            .setSourceLocation(location)
            .build();
    }

    /** Create an iterable containing a single statement. */
    private Iterable<StatementNode> single(StatementNode statement) {
        return ImmutableList.of(statement);
    }

    /** Create a statement list builder. */
    private ImmutableList.Builder<StatementNode> listBuilder() {
        return ImmutableList.builder();
    }
:}

parser code {:
    /** Generate source location information for a node given left and right character offsets. */
    private SourceRange location(int left, int right) {
        return ((ImpLexer) getScanner()).location(left, right);
    }

    @Override
    public void report_error(String message, Object info) {
        report_fatal_error(message, info);
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        done_parsing();

        final Symbol infoSymbol = (Symbol) info;
        final SourceRange errorLocation = location(infoSymbol.left, infoSymbol.right);
        final String actualToken = symbl_name_from_id(infoSymbol.sym);
        final List<String> expectedTokens = new LinkedList<>();
        for (Integer id : expected_token_ids()) {
            expectedTokens.add(symbl_name_from_id(id));
        }
        throw new ParsingError(errorLocation, actualToken, expectedTokens);
    }
:}

nonterminal ProgramNode program;
nonterminal ProgramNode.Builder declaration_list;
nonterminal TopLevelDeclarationNode declaration;
nonterminal Iterable<StatementNode> stmt, stmt_basic, stmt_noncontrol;
nonterminal VariableDeclarationNode variable_declaration;
nonterminal BlockNode block;
nonterminal BlockNode.Builder stmt_list;
nonterminal ReferenceNode reference;
nonterminal ExpressionNode expr;
nonterminal ImpValue value;
nonterminal Label label, label_expr, optional_label, optional_to;
nonterminal Variable variable;
nonterminal HostName host;
nonterminal ProcessName process_name;
nonterminal ImpBaseType type, optional_type;

terminal String IDENT, CAP_IDENT;
terminal AT;
terminal Integer INT_LIT;
terminal TRUE, FALSE;

terminal INT, BOOL;

terminal COLON;
terminal ASSERT, SEND, TO, RECV, FROM, IF, ELSE, WHILE, FOR;
terminal HOST, PROCESS, PROTOCOL, IDEAL;

terminal NOT, ANDAND, OROR;
terminal EQ, EQEQ, NEQ, LT, LEQ, GT, GEQ, PLUSEQ, MINUSEQ, TIMESEQ;
terminal TOP, BOTTOM, OR, AND, RARROW, LARROW;
terminal SQCUP, SQCAP, WEDGE, VEE, JOIN, MEET;

terminal PLUS, MINUS, TIMES, PLUSPLUS, MINUSMINUS;
// terminal PLUS, MINUS, TIMES, DIVIDE;

terminal DECLASSIFY, ENDORSE, DOWNGRADE;
terminal LET;

terminal OPEN_BRACE, CLOSE_BRACE, OPEN_SQBRACE, CLOSE_SQBRACE, SEMICOLON, OPEN_PAREN, CLOSE_PAREN, COMMA;

precedence left ANDAND, OROR, AND, OR, SQCUP, SQCAP, WEDGE, VEE, JOIN, MEET;
precedence nonassoc EQEQ, NEQ, LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT;
precedence left LARROW, RARROW, NOT;
precedence nonassoc OPEN_PAREN, CLOSE_PAREN;

start with program;


program ::=
    declaration_list:declarations {:
      RESULT = declarations
          .setSourceLocation(location(declarationsleft, declarationsright))
          .build();
  :}
  ;

declaration_list ::=
    declaration_list:declarations declaration:declaration {:
      RESULT = declarations.add(declaration);
    :}

  | /* empty */ {:
      RESULT = ProgramNode.builder();
  :}
  ;

declaration ::=
    HOST:begin host:host COLON label:trust SEMICOLON:end {:
      RESULT = HostDeclarationNode.builder()
          .setName(host)
          .setTrust(trust)
          .setSourceLocation(location(beginleft, endright))
          .build();
    :}

  | PROCESS:begin process_name:processName block:body {:
      RESULT = ProcessDeclarationNode.builder()
          .setName(processName)
          .setBody(body)
          .setSourceLocation(location(beginleft, bodyright))
          .build();
    :}
  ;


stmt ::=
    stmt_basic:stmt SEMICOLON {:
      RESULT = stmt;
    :}

  | IF:begin OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase ELSE block:elseCase {:
      RESULT = single(
          IfNode.builder()
          .setGuard(guard)
          .setThenBranch(thenCase)
          .setElseBranch(elseCase)
          .setSourceLocation(location(beginleft, elseCaseright))
          .build());
    :}

  | IF:begin OPEN_PAREN expr:guard CLOSE_PAREN block:thenCase {:
      RESULT = single(
          IfNode.builder()
          .setGuard(guard)
          .setThenBranch(thenCase)
          .setSourceLocation(location(beginleft, thenCaseright))
          .build());
    :}

  | WHILE:begin OPEN_PAREN expr:guard CLOSE_PAREN block:body {:
      RESULT = single(
          WhileNode.builder()
          .setGuard(guard)
          .setBody(body)
          .setSourceLocation(location(beginleft, bodyright))
          .build());
    :}

  | FOR:begin OPEN_PAREN stmt_noncontrol:initList SEMICOLON expr:guard SEMICOLON stmt_noncontrol:updateList CLOSE_PAREN block:body {:
      RESULT = single(
          ForNode.builder()
          .setInitialize(initList)
          .setGuard(guard)
          .setUpdate(updateList)
          .setBody(body)
          .setSourceLocation(location(beginleft, bodyright))
          .build());
    :}

  | block:block {:
      RESULT = single(block);
    :}
  ;

stmt_noncontrol ::=
    stmt_basic:stmt_list {:
        RESULT = stmt_list;
      :}

    | block:block {:
        RESULT = block.getStatements();
      :}
    ;

stmt_basic ::=
    variable_declaration:decl {:
      RESULT = single(decl);
    :}

  | variable_declaration:decl EQ expr:e {:
      RESULT = listBuilder()
        .add(decl)
        .add(
            AssignNode.builder()
            .setLhs(decl.getVariable())
            .setRhs(e)
            .setSourceLocation(location(declleft, eright))
            .build()
        )
        .build();
    :}

  | type:ty optional_label:lab variable:var OPEN_SQBRACE expr:e CLOSE_SQBRACE:end {:
      RESULT = single(
          ArrayDeclarationNode.builder()
          .setVariable(var)
          .setLength(e)
          .setElementType(ty)
          .setLabel(lab)
          .setSourceLocation(location(tyleft, endright))
          .build());
    :}

  | LET:begin variable:var EQ expr:e {:
      RESULT = single(
          LetBindingNode.builder()
          .setVariable(var)
          .setRhs(e)
          .setSourceLocation(location(beginleft, eright))
          .build());
    :}

  | reference:ref EQ expr:e {:
      RESULT = single(
           AssignNode.builder()
          .setLhs(ref)
          .setRhs(e)
          .setSourceLocation(location(refleft, eright))
          .build());
    :}

  | reference:ref PLUSEQ expr:e {:
      RESULT = single(opAssign(Plus.create(), ref, e));
    :}

  | reference:ref MINUSEQ expr:e {:
      RESULT = single(opAssign(Minus.create(), ref, e));
    :}

  | reference:ref TIMESEQ expr:e {:
      RESULT = single(opAssign(Times.create(), ref, e));
    :}

  | SEND:begin expr:e TO process_name:recipient {:
      RESULT = single(
          SendNode.builder()
          .setRecipient(recipient)
          .setSentExpression(e)
          .setSourceLocation(location(beginleft, recipientright))
          .build());
    :}

  | variable:var LARROW RECV optional_type:ty process_name:sender {:
      RESULT = single(
          ReceiveNode.builder()
          .setVariable(var)
          .setReceiveType(ty)
          .setSender(sender)
          .setSourceLocation(location(varleft, senderright))
          .build());
    :}

  | variable_declaration:decl LARROW RECV optional_type:ty process_name:sender {:
      RESULT = listBuilder()
          .add(decl)
          .add(ReceiveNode.builder()
              .setVariable(decl.getVariable())
              .setReceiveType(ty)
              .setSender(sender)
              .setSourceLocation(location(declleft, senderright))
              .build()
          )
          .build();
    :}

  | ASSERT:begin expr:e {:
      RESULT = single(
          AssertNode.builder()
          .setExpression(e)
          .setSourceLocation(location(beginleft, eright))
          .build());
    :}
  ;

variable_declaration ::=
    type:ty optional_label:lab variable:var {:
      RESULT = VariableDeclarationNode.builder()
          .setVariable(var)
          .setType(ty)
          .setLabel(lab)
          .setSourceLocation(location(tyleft, varright))
          .build();
    :}
  ;

block ::=
    OPEN_BRACE:begin stmt_list:slist CLOSE_BRACE:end {:
      RESULT = slist.setSourceLocation(location(beginleft, endright)).build();
    :}
  ;

stmt_list ::=
    stmt_list:slist stmt:s {:
      RESULT = slist.addAll(s);
    :}

  | /* empty */ {:
      RESULT = BlockNode.builder();
    :}
  ;


reference ::=
    variable:var OPEN_SQBRACE expr:e CLOSE_SQBRACE:end {:
      RESULT = ArrayIndexingNode.builder()
          .setArray(var)
          .setIndex(e)
          .setSourceLocation(location(varleft, endright))
          .build();
    :}

  | variable:var {:
      RESULT = var;
    :}
  ;


expr ::=
    value:value {:
      RESULT = LiteralNode.builder()
          .setValue(value)
          .setSourceLocation(location(valueleft, valueright))
          .build();
    :}

  | reference:ref {:
       RESULT = ReadNode.builder().setReference(ref).setSourceLocation(ref).build();
    :}

  | NOT:begin expr:e {:
      RESULT = NotNode.builder()
          .setExpression(e)
          .setSourceLocation(location(beginleft, eright))
          .build();
    :}

  | expr:e1 ANDAND expr:e2 {:
      RESULT = binary(And.create(), e1, e2);
    :}

  | expr:e1 OROR expr:e2 {:
      RESULT = binary(Or.create(), e1, e2);
    :}

  | expr:e1 EQEQ expr:e2 {:
      RESULT = binary(EqualTo.create(), e1, e2);
    :}

  | expr:e1 NEQ expr:e2 {:
      final ExpressionNode eq = binary(EqualTo.create(), e1, e2);
      RESULT = NotNode.builder()
          .setExpression(eq)
          .setSourceLocation(eq)
          .build();
    :}

  | expr:e1 LT expr:e2 {:
      RESULT = binary(LessThan.create(), e1, e2);
    :}

  | expr:e1 LEQ expr:e2 {:
      RESULT = binary(LessThanOrEqualTo.create(), e1, e2);
    :}

  | expr:e1 GT expr:e2 {:
      RESULT = binary(LessThan.create(), e2, e1);
    :}

  | expr:e1 GEQ expr:e2 {:
      RESULT = binary(LessThanOrEqualTo.create(), e2, e1);
    :}

  | expr:e1 PLUS expr:e2 {:
      RESULT = binary(Plus.create(), e1, e2);
    :}

  | expr:e1 MINUS expr:e2 {:
      RESULT = binary(Minus.create(), e1, e2);
    :}

  | expr:e1 TIMES expr:e2 {:
      RESULT = binary(Times.create(), e1, e2);
    :}

  | MINUS:begin expr:e {:
      final LiteralNode zero = LiteralNode.builder()
          .setValue(IntegerValue.create(0))
          .setSourceLocation(location(beginleft, beginright))
          .build();
      RESULT = binary(Minus.create(), zero, e);
    :}

  | DECLASSIFY:begin OPEN_PAREN expr:e COMMA label:first optional_to:second CLOSE_PAREN:end {:
      RESULT = downgrade(DowngradeType.DECLASSIFY, e, first, second, location(beginleft, endright));
    :}

  | ENDORSE:begin OPEN_PAREN expr:e COMMA label:first optional_to:second CLOSE_PAREN:end {:
      RESULT = downgrade(DowngradeType.ENDORSE, e, first, second, location(beginleft, endright));
    :}

  | DOWNGRADE:begin OPEN_PAREN expr:e COMMA label:first optional_to:second CLOSE_PAREN:end {:
      RESULT = downgrade(DowngradeType.BOTH, e, first, second, location(beginleft, endright));
    :}

  | OPEN_PAREN expr:e CLOSE_PAREN {:
      RESULT = e;
    :}
  ;

value ::=
    TRUE {:
      RESULT = BooleanValue.create(true);
    :}

  | FALSE {:
      RESULT = BooleanValue.create(false);
    :}

  | INT_LIT:lit {:
      RESULT = IntegerValue.create(lit);
    :}
  ;


optional_type ::=
    type:ty {:
        RESULT = ty;
    :}
  | /* nothing */ {:
        RESULT = null;
    :}
  ;

optional_label ::=
    label:l {:
        RESULT = l;
    :}
  | /* nothing */ {:
        RESULT = null;
    :}
  ;

optional_to ::=
    TO label:l {:
        RESULT = l;
    :}
  | /* nothing */ {:
        RESULT = null;
    :}
  ;


type ::=
    INT {: RESULT = IntegerType.create(); :}
  | BOOL {: RESULT = BooleanType.create(); :}
  ;


label ::=
    OPEN_BRACE CLOSE_BRACE {: RESULT = Label.weakest(); :}
  | OPEN_BRACE label_expr:l CLOSE_BRACE {: RESULT = l; :}
  ;

label_expr ::=
    CAP_IDENT:id {: RESULT = Label.create(Principal.create(id)); :}

  | TOP {: RESULT = Label.weakest(); :}

  | BOTTOM {: RESULT = Label.strongest(); :}

  | label_expr:l1 OR label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 VEE label_expr:l2 {:
      RESULT = l1.or(l2);
    :}

  | label_expr:l1 AND label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 WEDGE label_expr:l2 {:
      RESULT = l1.and(l2);
    :}

  | label_expr:l1 SQCUP label_expr:l2 {:
      RESULT = l1.join(l2);
    :}

  | label_expr:l1 JOIN label_expr:l2 {:
      RESULT = l1.join(l2);
    :}

  | label_expr:l1 SQCAP label_expr:l2 {:
      RESULT = l1.meet(l2);
    :}

  | label_expr:l1 MEET label_expr:l2 {:
      RESULT = l1.meet(l2);
    :}

  | label_expr:l RARROW {:
      RESULT = l.confidentiality();
    :}

  | label_expr:l LARROW {:
      RESULT = l.integrity();
    :}

  | OPEN_PAREN label_expr:l CLOSE_PAREN {:
      RESULT = l;
    :}
  ;


variable ::=
    IDENT:id  {:
      RESULT = Variable.builder()
          .setName(id)
          .setSourceLocation(location(idleft, idright))
          .build();
  :}
  ;

host ::=
    IDENT:id {:
      RESULT = HostName.builder()
          .setName(id)
          .setSourceLocation(location(idleft, idright))
          .build();
  :}
  ;

process_name ::=
    IDENT:id {:
      RESULT = ProcessName.builder()
          .setName(id)
          .setSourceLocation(location(idleft, idright))
          .build();
    :}

  | AT host:host {:
      RESULT = ProcessName.create(host);
    :}
  ;
